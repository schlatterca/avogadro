import { h as k, defineComponent as W, openBlock as F, createBlock as H } from "vue";
function S(e, n) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    n && (r = r.filter(function(c) {
      return Object.getOwnPropertyDescriptor(e, c).enumerable;
    })), t.push.apply(t, r);
  }
  return t;
}
function D(e) {
  for (var n = 1; n < arguments.length; n++) {
    var t = arguments[n] != null ? arguments[n] : {};
    n % 2 ? S(Object(t), !0).forEach(function(r) {
      q(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : S(Object(t)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function q(e, n, t) {
  return n = R(n), n in e ? Object.defineProperty(e, n, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[n] = t, e;
}
function R(e) {
  var n = z(e, "string");
  return typeof n == "symbol" ? n : n + "";
}
function z(e, n) {
  if (typeof e != "object" || !e)
    return e;
  var t = e[Symbol.toPrimitive];
  if (t !== void 0) {
    var r = t.call(e, n || "default");
    if (typeof r != "object")
      return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (n === "string" ? String : Number)(e);
}
function x(e) {
  return e._type === "span" && "text" in e && typeof e.text == "string" && (typeof e.marks > "u" || Array.isArray(e.marks) && e.marks.every((n) => typeof n == "string"));
}
function P(e) {
  return (
    // A block doesn't _have_ to be named 'block' - to differentiate between
    // allowed child types and marks, one might name them differently
    typeof e._type == "string" && // Toolkit-types like nested spans are @-prefixed
    e._type[0] !== "@" && // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array
    (!("markDefs" in e) || !e.markDefs || Array.isArray(e.markDefs) && // Every mark definition needs to have an `_key` to be mappable in child spans
    e.markDefs.every((n) => typeof n._key == "string")) && // `children` is required and needs to be an array
    "children" in e && Array.isArray(e.children) && // All children are objects with `_type` (usually spans, but can contain other stuff)
    e.children.every((n) => typeof n == "object" && "_type" in n)
  );
}
function A(e) {
  return P(e) && "listItem" in e && typeof e.listItem == "string" && (typeof e.level > "u" || typeof e.level == "number");
}
function E(e) {
  return e._type === "@list";
}
function N(e) {
  return e._type === "@span";
}
function U(e) {
  return e._type === "@text";
}
const B = ["strong", "em", "code", "underline", "strike-through"];
function V(e, n, t) {
  if (!x(e) || !e.marks)
    return [];
  if (!e.marks.length)
    return [];
  const r = e.marks.slice(), c = {};
  return r.forEach((i) => {
    c[i] = 1;
    for (let s = n + 1; s < t.length; s++) {
      const f = t[s];
      if (f && x(f) && Array.isArray(f.marks) && f.marks.indexOf(i) !== -1)
        c[i]++;
      else
        break;
    }
  }), r.sort((i, s) => G(c, i, s));
}
function G(e, n, t) {
  const r = e[n], c = e[t];
  if (r !== c)
    return c - r;
  const i = B.indexOf(n), s = B.indexOf(t);
  return i !== s ? i - s : n.localeCompare(t);
}
function J(e) {
  var n;
  const {
    children: t,
    markDefs: r = []
  } = e;
  if (!t || !t.length)
    return [];
  const c = t.map(V), i = {
    _type: "@span",
    children: [],
    markType: "<unknown>"
  };
  let s = [i];
  for (let f = 0; f < t.length; f++) {
    const d = t[f];
    if (!d)
      continue;
    const w = c[f] || [];
    let b = 1;
    if (s.length > 1)
      for (b; b < s.length; b++) {
        const o = ((n = s[b]) == null ? void 0 : n.markKey) || "", u = w.indexOf(o);
        if (u === -1)
          break;
        w.splice(u, 1);
      }
    s = s.slice(0, b);
    let l = s[s.length - 1];
    if (l) {
      for (const o of w) {
        const u = r.find((m) => m._key === o), p = u ? u._type : o, a = {
          _type: "@span",
          _key: d._key,
          children: [],
          markDef: u,
          markType: p,
          markKey: o
        };
        l.children.push(a), s.push(a), l = a;
      }
      if (x(d)) {
        const o = d.text.split(`
`);
        for (let u = o.length; u-- > 1; )
          o.splice(u, 0, `
`);
        l.children = l.children.concat(o.map((u) => ({
          _type: "@text",
          text: u
        })));
      } else
        l.children = l.children.concat(d);
    }
  }
  return i.children;
}
function Q(e, n) {
  const t = [];
  let r;
  for (let c = 0; c < e.length; c++) {
    const i = e[c];
    if (i) {
      if (!A(i)) {
        t.push(i), r = void 0;
        continue;
      }
      if (!r) {
        r = O(i, c, n), t.push(r);
        continue;
      }
      if (X(i, r)) {
        r.children.push(i);
        continue;
      }
      if ((i.level || 1) > r.level) {
        const s = O(i, c, n);
        if (n === "html") {
          const f = r.children[r.children.length - 1], d = D(D({}, f), {}, {
            children: [...f.children, s]
          });
          r.children[r.children.length - 1] = d;
        } else
          r.children.push(s);
        r = s;
        continue;
      }
      if ((i.level || 1) < r.level) {
        const s = t[t.length - 1], f = s && L(s, i);
        if (f) {
          r = f, r.children.push(i);
          continue;
        }
        r = O(i, c, n), t.push(r);
        continue;
      }
      if (i.listItem !== r.listItem) {
        const s = t[t.length - 1], f = s && L(s, {
          level: i.level || 1
        });
        if (f && f.listItem === i.listItem) {
          r = f, r.children.push(i);
          continue;
        } else {
          r = O(i, c, n), t.push(r);
          continue;
        }
      }
      console.warn("Unknown state encountered for block", i), t.push(i);
    }
  }
  return t;
}
function X(e, n) {
  return (e.level || 1) === n.level && e.listItem === n.listItem;
}
function O(e, n, t) {
  return {
    _type: "@list",
    _key: `${e._key || `${n}`}-parent`,
    mode: t,
    level: e.level || 1,
    listItem: e.listItem,
    children: [e]
  };
}
function L(e, n) {
  const t = n.level || 1, r = n.listItem || "normal", c = typeof n.listItem == "string";
  if (E(e) && (e.level || 1) === t && c && (e.listItem || "normal") === r)
    return e;
  if (!("children" in e))
    return;
  const i = e.children[e.children.length - 1];
  return i && !x(i) ? L(i, n) : void 0;
}
function K(e) {
  let n = "";
  return e.children.forEach((t) => {
    U(t) ? n += t.text : N(t) && (n += K(t));
  }), n;
}
const Y = /^\s/, Z = /^\s/;
function we(e) {
  const n = Array.isArray(e) ? e : [e];
  let t = "";
  return n.forEach((r, c) => {
    if (!P(r))
      return;
    let i = !1;
    r.children.forEach((s) => {
      x(s) ? (t += i && t && !Z.test(t) && !Y.test(s.text) ? " " : "", t += s.text, i = !1) : i = !0;
    }), c !== n.length - 1 && (t += `

`);
  }), t;
}
const ee = "html";
function te(e, n) {
  const { block: t, list: r, listItem: c, marks: i, types: s, ...f } = n;
  return {
    ...e,
    block: v(e, n, "block"),
    list: v(e, n, "list"),
    listItem: v(e, n, "listItem"),
    marks: v(e, n, "marks"),
    types: v(e, n, "types"),
    ...f
  };
}
function v(e, n, t) {
  const r = n[t], c = e[t];
  return typeof r == "function" || r && typeof c == "function" ? r : r ? {
    ...c,
    ...r
  } : c;
}
const y = (e) => (n, { slots: t }) => {
  var r;
  return k(e, (r = t.default) == null ? void 0 : r.call(t));
}, ne = ({ value: e }, { slots: n }) => {
  var t;
  return k("a", { href: e == null ? void 0 : e.href }, (t = n.default) == null ? void 0 : t.call(n));
}, re = { textDecoration: "underline" }, ie = {
  code: y("code"),
  em: y("em"),
  link: ne,
  "strike-through": y("del"),
  strong: y("strong"),
  underline: (e, { slots: n }) => {
    var t;
    return k("span", { style: re }, (t = n.default) == null ? void 0 : t.call(n));
  }
}, le = {
  number: y("ol"),
  bullet: y("ul")
}, oe = y("li"), T = (e, n) => `[@portabletext/vue] Unknown ${e}, specify a component for it in the \`components.${n}\` prop`, C = (e) => T(`block type "${e}"`, "types"), se = (e) => T(`mark type "${e}"`, "marks"), ce = (e) => T(`block style "${e}"`, "block"), ue = (e) => T(`list style "${e}"`, "list"), ae = (e) => T(`list item style "${e}"`, "listItem");
function fe(e) {
  console.warn(e);
}
const M = { display: "none" }, ye = ({
  value: e,
  isInline: n
}) => {
  const t = C(e._type);
  return n ? k("span", { style: M }, t) : k("div", { style: M }, t);
}, pe = ({ markType: e }, { slots: n }) => {
  var t;
  return k("span", { class: `unknown__pt__mark__${e}` }, (t = n.default) == null ? void 0 : t.call(n));
}, ke = y("p"), he = y("ul"), de = y("li"), me = () => k("br"), ge = {
  normal: y("p"),
  blockquote: y("blockquote"),
  h1: y("h1"),
  h2: y("h2"),
  h3: y("h3"),
  h4: y("h4"),
  h5: y("h5"),
  h6: y("h6")
}, $ = {
  types: {},
  block: ge,
  marks: ie,
  list: le,
  listItem: oe,
  hardBreak: me,
  unknownType: ye,
  unknownMark: pe,
  unknownList: he,
  unknownListItem: de,
  unknownBlockStyle: ke
}, Ie = (e, n = !1) => (t) => {
  if (n) {
    const { value: r, ...c } = t;
    return k(e, { ...c, ...r });
  }
  return k(e, { ...t.value });
}, be = (e, n) => {
  function t(l) {
    const { node: o, index: u, isInline: p } = l, a = o._key || `node-${u}`;
    return E(o) ? i(o, u, a) : A(o) ? c(o, u, a) : N(o) ? s(o, u, a) : r(o) ? b(o, u, a, p) : P(o) ? f(o, u, a, p) : U(o) ? d(o, a) : w(o, u, a, p);
  }
  function r(l) {
    return l._type in e.types;
  }
  function c(l, o, u) {
    const p = j({ node: l, index: o, isInline: !1, renderNode: t }), a = e.listItem, g = (typeof a == "function" ? a : a[l.listItem]) || e.unknownListItem;
    if (g === e.unknownListItem) {
      const _ = l.listItem || "bullet";
      n(ae(_), {
        type: _,
        nodeType: "listItemStyle"
      });
    }
    let h = p.children;
    if (l.style && l.style !== "normal") {
      const { listItem: _, ...I } = l;
      h = t({
        node: I,
        index: o,
        isInline: !1,
        renderNode: t
      });
    }
    return k(
      g,
      {
        key: u,
        value: l,
        index: o,
        isInline: !1,
        renderNode: t
      },
      () => h
    );
  }
  function i(l, o, u) {
    const p = l.children.map(
      (h, _) => t({
        node: h._key ? h : { ...h, _key: `li-${o}-${_}` },
        index: _,
        isInline: !1,
        renderNode: t
      })
    ), a = e.list, g = (typeof a == "function" ? a : a[l.listItem]) || e.unknownList;
    if (g === e.unknownList) {
      const h = l.listItem || "bullet";
      n(ue(h), {
        nodeType: "listStyle",
        type: h
      });
    }
    return k(
      g,
      {
        key: u,
        value: l,
        index: o,
        isInline: !1,
        renderNode: t
      },
      () => p
    );
  }
  function s(l, o, u) {
    const { markDef: p, markType: a, markKey: m } = l, g = e.marks[a] || e.unknownMark, h = l.children.map(
      (_, I) => t({ node: _, index: I, isInline: !0, renderNode: t })
    );
    return g === e.unknownMark && n(se(a), {
      nodeType: "mark",
      type: a
    }), k(
      g,
      {
        key: u,
        text: K(l),
        value: p,
        markType: a,
        markKey: m,
        renderNode: t
      },
      () => h
    );
  }
  function f(l, o, u, p) {
    const { _key: a, children: m, ...g } = j({
      node: l,
      index: o,
      isInline: p,
      renderNode: t
    }), h = g.node.style || "normal", I = (typeof e.block == "function" ? e.block : e.block[h]) || e.unknownBlockStyle;
    return I === e.unknownBlockStyle && n(ce(h), {
      nodeType: "blockStyle",
      type: h
    }), k(I, { key: u, ...g, value: g.node, renderNode: t }, () => m);
  }
  function d(l, o) {
    if (l.text === `
`) {
      const u = e.hardBreak;
      return u ? k(u, { key: o }) : `
`;
    }
    return l.text;
  }
  function w(l, o, u, p) {
    const a = {
      value: l,
      isInline: p,
      index: o,
      renderNode: t
    };
    n(C(l._type), {
      nodeType: "block",
      type: l._type
    });
    const m = e.unknownType;
    return k(m, { key: u, ...a });
  }
  function b(l, o, u, p) {
    const a = {
      value: l,
      isInline: p,
      index: o,
      renderNode: t
    }, m = e.types[l._type];
    return m ? k(m, { key: u, ...a }) : void 0;
  }
  return t;
};
function j(e) {
  const { node: n, index: t, isInline: r, renderNode: c } = e, s = J(n).map(
    (f, d) => c({ node: f, isInline: !0, index: d, renderNode: c })
  );
  return {
    _key: n._key || `block-${t}`,
    children: s,
    index: t,
    isInline: r,
    node: n
  };
}
const ve = /* @__PURE__ */ W({
  __name: "vue-portable-text",
  props: {
    value: {},
    components: {},
    onMissingComponent: { type: [Function, Boolean], default: () => fe },
    listNestingMode: {}
  },
  setup(e) {
    function n() {
    }
    const t = e, r = () => {
      const c = t.onMissingComponent || n, i = Array.isArray(t.value) ? t.value : [t.value], s = Q(i, t.listNestingMode || ee), f = t.components ? te($, t.components) : $, d = be(f, c);
      return s.map(
        (b, l) => d({ node: b, index: l, isInline: !1, renderNode: d })
      );
    };
    return (c, i) => (F(), H(r));
  }
});
export {
  ve as PortableText,
  $ as defaultComponents,
  Ie as flattenProps,
  te as mergeComponents,
  we as toPlainText
};
