{"file":"_slug_-BMxz5cEw.js","mappings":"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","names":["createSanityClient","sanity","myData"],"sources":["../../../../node_modules/nuxt/dist/app/composables/asyncData.js","../../../../node_modules/@nuxtjs/sanity/dist/runtime/groq.mjs","../../../../node_modules/@nuxtjs/sanity/dist/runtime/composables/index.mjs","../../../../pages/progetti/[slug].vue"],"sourcesContent":["import { computed, getCurrentInstance, getCurrentScope, onBeforeMount, onScopeDispose, onServerPrefetch, onUnmounted, ref, shallowRef, toRef, unref, watch } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { toArray } from \"../utils.js\";\nimport { createError } from \"./error.js\";\nimport { onNuxtReady } from \"./ready.js\";\nimport { asyncDataDefaults, resetAsyncDataToUndefined } from \"#build/nuxt.config.mjs\";\nconst isDefer = (dedupe) => dedupe === \"defer\" || dedupe === false;\nexport function useAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (typeof args[0] !== \"string\") {\n    args.unshift(autoKey);\n  }\n  let [key, _handler, options = {}] = args;\n  if (typeof key !== \"string\") {\n    throw new TypeError(\"[nuxt] [asyncData] key must be a string.\");\n  }\n  if (typeof _handler !== \"function\") {\n    throw new TypeError(\"[nuxt] [asyncData] handler must be a function.\");\n  }\n  const nuxtApp = useNuxtApp();\n  const handler = import.meta.client || !import.meta.prerender || !nuxtApp.ssrContext?._sharedPrerenderCache ? _handler : () => {\n    const value = nuxtApp.ssrContext._sharedPrerenderCache.get(key);\n    if (value) {\n      return value;\n    }\n    const promise = Promise.resolve().then(() => nuxtApp.runWithContext(_handler));\n    nuxtApp.ssrContext._sharedPrerenderCache.set(key, promise);\n    return promise;\n  };\n  const getDefault = () => asyncDataDefaults.value;\n  const getDefaultCachedData = () => nuxtApp.isHydrating ? nuxtApp.payload.data[key] : nuxtApp.static.data[key];\n  options.server = options.server ?? true;\n  options.default = options.default ?? getDefault;\n  options.getCachedData = options.getCachedData ?? getDefaultCachedData;\n  options.lazy = options.lazy ?? false;\n  options.immediate = options.immediate ?? true;\n  options.deep = options.deep ?? asyncDataDefaults.deep;\n  options.dedupe = options.dedupe ?? \"cancel\";\n  if (import.meta.dev && typeof options.dedupe === \"boolean\") {\n    console.warn(\"[nuxt] `boolean` values are deprecated for the `dedupe` option of `useAsyncData` and will be removed in the future. Use 'cancel' or 'defer' instead.\");\n  }\n  const initialCachedData = options.getCachedData(key, nuxtApp);\n  const hasCachedData = initialCachedData != null;\n  if (!nuxtApp._asyncData[key] || !options.immediate) {\n    nuxtApp.payload._errors[key] ??= asyncDataDefaults.errorValue;\n    const _ref = options.deep ? ref : shallowRef;\n    nuxtApp._asyncData[key] = {\n      data: _ref(hasCachedData ? initialCachedData : options.default()),\n      pending: ref(!hasCachedData),\n      error: toRef(nuxtApp.payload._errors, key),\n      status: ref(\"idle\"),\n      _default: options.default\n    };\n  }\n  const asyncData = { ...nuxtApp._asyncData[key] };\n  delete asyncData._default;\n  asyncData.refresh = asyncData.execute = (opts = {}) => {\n    if (nuxtApp._asyncDataPromises[key]) {\n      if (isDefer(opts.dedupe ?? options.dedupe)) {\n        return nuxtApp._asyncDataPromises[key];\n      }\n      nuxtApp._asyncDataPromises[key].cancelled = true;\n    }\n    if (opts._initial || nuxtApp.isHydrating && opts._initial !== false) {\n      const cachedData = opts._initial ? initialCachedData : options.getCachedData(key, nuxtApp);\n      if (cachedData != null) {\n        return Promise.resolve(cachedData);\n      }\n    }\n    asyncData.pending.value = true;\n    asyncData.status.value = \"pending\";\n    const promise = new Promise(\n      (resolve, reject) => {\n        try {\n          resolve(handler(nuxtApp));\n        } catch (err) {\n          reject(err);\n        }\n      }\n    ).then(async (_result) => {\n      if (promise.cancelled) {\n        return nuxtApp._asyncDataPromises[key];\n      }\n      let result = _result;\n      if (options.transform) {\n        result = await options.transform(_result);\n      }\n      if (options.pick) {\n        result = pick(result, options.pick);\n      }\n      if (import.meta.dev && import.meta.server && typeof result === \"undefined\") {\n        console.warn(`[nuxt] \\`${options._functionName || \"useAsyncData\"}\\` must return a value (it should not be \\`undefined\\`) or the request may be duplicated on the client side.`);\n      }\n      nuxtApp.payload.data[key] = result;\n      asyncData.data.value = result;\n      asyncData.error.value = asyncDataDefaults.errorValue;\n      asyncData.status.value = \"success\";\n    }).catch((error) => {\n      if (promise.cancelled) {\n        return nuxtApp._asyncDataPromises[key];\n      }\n      asyncData.error.value = createError(error);\n      asyncData.data.value = unref(options.default());\n      asyncData.status.value = \"error\";\n    }).finally(() => {\n      if (promise.cancelled) {\n        return;\n      }\n      asyncData.pending.value = false;\n      delete nuxtApp._asyncDataPromises[key];\n    });\n    nuxtApp._asyncDataPromises[key] = promise;\n    return nuxtApp._asyncDataPromises[key];\n  };\n  asyncData.clear = () => clearNuxtDataByKey(nuxtApp, key);\n  const initialFetch = () => asyncData.refresh({ _initial: true });\n  const fetchOnServer = options.server !== false && nuxtApp.payload.serverRendered;\n  if (import.meta.server && fetchOnServer && options.immediate) {\n    const promise = initialFetch();\n    if (getCurrentInstance()) {\n      onServerPrefetch(() => promise);\n    } else {\n      nuxtApp.hook(\"app:created\", async () => {\n        await promise;\n      });\n    }\n  }\n  if (import.meta.client) {\n    const instance = getCurrentInstance();\n    if (import.meta.dev && !nuxtApp.isHydrating && !nuxtApp._processingMiddleware && (!instance || instance?.isMounted)) {\n      console.warn(`[nuxt] [${options._functionName || \"useAsyncData\"}] Component is already mounted, please use $fetch instead. See https://nuxt.com/docs/getting-started/data-fetching`);\n    }\n    if (instance && !instance._nuxtOnBeforeMountCbs) {\n      instance._nuxtOnBeforeMountCbs = [];\n      const cbs = instance._nuxtOnBeforeMountCbs;\n      onBeforeMount(() => {\n        cbs.forEach((cb) => {\n          cb();\n        });\n        cbs.splice(0, cbs.length);\n      });\n      onUnmounted(() => cbs.splice(0, cbs.length));\n    }\n    if (fetchOnServer && nuxtApp.isHydrating && (asyncData.error.value || initialCachedData != null)) {\n      asyncData.pending.value = false;\n      asyncData.status.value = asyncData.error.value ? \"error\" : \"success\";\n    } else if (instance && (nuxtApp.payload.serverRendered && nuxtApp.isHydrating || options.lazy) && options.immediate) {\n      instance._nuxtOnBeforeMountCbs.push(initialFetch);\n    } else if (options.immediate) {\n      initialFetch();\n    }\n    const hasScope = getCurrentScope();\n    if (options.watch) {\n      const unsub = watch(options.watch, () => asyncData.refresh());\n      if (hasScope) {\n        onScopeDispose(unsub);\n      }\n    }\n    const off = nuxtApp.hook(\"app:data:refresh\", async (keys) => {\n      if (!keys || keys.includes(key)) {\n        await asyncData.refresh();\n      }\n    });\n    if (hasScope) {\n      onScopeDispose(off);\n    }\n  }\n  const asyncDataPromise = Promise.resolve(nuxtApp._asyncDataPromises[key]).then(() => asyncData);\n  Object.assign(asyncDataPromise, asyncData);\n  return asyncDataPromise;\n}\nexport function useLazyAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (typeof args[0] !== \"string\") {\n    args.unshift(autoKey);\n  }\n  const [key, handler, options = {}] = args;\n  if (import.meta.dev && import.meta.client) {\n    options._functionName ||= \"useLazyAsyncData\";\n  }\n  return useAsyncData(key, handler, { ...options, lazy: true }, null);\n}\nexport function useNuxtData(key) {\n  const nuxtApp = useNuxtApp();\n  if (!(key in nuxtApp.payload.data)) {\n    nuxtApp.payload.data[key] = asyncDataDefaults.value;\n  }\n  return {\n    data: computed({\n      get() {\n        return nuxtApp._asyncData[key]?.data.value ?? nuxtApp.payload.data[key];\n      },\n      set(value) {\n        if (nuxtApp._asyncData[key]) {\n          nuxtApp._asyncData[key].data.value = value;\n        } else {\n          nuxtApp.payload.data[key] = value;\n        }\n      }\n    })\n  };\n}\nexport async function refreshNuxtData(keys) {\n  if (import.meta.server) {\n    return Promise.resolve();\n  }\n  await new Promise((resolve) => onNuxtReady(resolve));\n  const _keys = keys ? toArray(keys) : void 0;\n  await useNuxtApp().hooks.callHookParallel(\"app:data:refresh\", _keys);\n}\nexport function clearNuxtData(keys) {\n  const nuxtApp = useNuxtApp();\n  const _allKeys = Object.keys(nuxtApp.payload.data);\n  const _keys = !keys ? _allKeys : typeof keys === \"function\" ? _allKeys.filter(keys) : toArray(keys);\n  for (const key of _keys) {\n    clearNuxtDataByKey(nuxtApp, key);\n  }\n}\nfunction clearNuxtDataByKey(nuxtApp, key) {\n  if (key in nuxtApp.payload.data) {\n    nuxtApp.payload.data[key] = void 0;\n  }\n  if (key in nuxtApp.payload._errors) {\n    nuxtApp.payload._errors[key] = asyncDataDefaults.errorValue;\n  }\n  if (nuxtApp._asyncData[key]) {\n    nuxtApp._asyncData[key].data.value = resetAsyncDataToUndefined ? void 0 : nuxtApp._asyncData[key]._default();\n    nuxtApp._asyncData[key].error.value = asyncDataDefaults.errorValue;\n    nuxtApp._asyncData[key].pending.value = false;\n    nuxtApp._asyncData[key].status.value = \"idle\";\n  }\n  if (key in nuxtApp._asyncDataPromises) {\n    if (nuxtApp._asyncDataPromises[key]) {\n      nuxtApp._asyncDataPromises[key].cancelled = true;\n    }\n    nuxtApp._asyncDataPromises[key] = void 0;\n  }\n}\nfunction pick(obj, keys) {\n  const newObj = {};\n  for (const key of keys) {\n    newObj[key] = obj[key];\n  }\n  return newObj;\n}\n","export const groq = String.raw || ((strings, ...keys) => {\n  const lastIndex = strings.length - 1;\n  return strings.slice(0, lastIndex).reduce(\n    (query, currentString, index) => query + currentString + keys[index],\n    \"\"\n  ) + strings[lastIndex];\n});\n","import { defu } from \"defu\";\nimport { hash } from \"ohash\";\nimport { reactive } from \"vue\";\nimport { useNuxtApp, useRuntimeConfig, useAsyncData, useLazyAsyncData, createSanityClient } from \"#imports\";\nconst createSanityHelper = (options) => {\n  const config = { ...options };\n  let client = createSanityClient(config);\n  return {\n    client,\n    config,\n    // @ts-expect-error untyped args\n    fetch: (...args) => client.fetch(...args),\n    setToken(token) {\n      config.token = token;\n      client = createSanityClient(config);\n    }\n  };\n};\nexport const useSanity = (client = \"default\") => {\n  const nuxtApp = useNuxtApp();\n  if (nuxtApp._sanity?.[client]) {\n    return nuxtApp._sanity[client];\n  }\n  nuxtApp._sanity = nuxtApp._sanity || {};\n  const $config = useRuntimeConfig();\n  const { additionalClients = {}, ...options } = defu($config.sanity, $config.public.sanity);\n  if (!options.disableSmartCdn && nuxtApp.$preview) {\n    options.useCdn = false;\n  } else if (!import.meta.dev && !options.useCdn && !options.token) {\n    options.useCdn = true;\n  }\n  if (client === \"default\") {\n    nuxtApp._sanity.default = createSanityHelper(options);\n    return nuxtApp._sanity.default;\n  }\n  nuxtApp._sanity[client] = createSanityHelper(defu(additionalClients[client], options));\n  return nuxtApp._sanity[client];\n};\nexport const useSanityQuery = (query, _params, _options = {}) => {\n  const { client, ...options } = _options;\n  const sanity = useSanity(client);\n  const params = _params ? reactive(_params) : void 0;\n  if (params) {\n    options.watch = options.watch || [];\n    options.watch.push(params);\n  }\n  return useAsyncData(\"sanity-\" + hash(query + (params ? JSON.stringify(params) : \"\")), () => sanity.fetch(query, params || {}), options);\n};\nexport const useLazySanityQuery = (query, _params, _options = {}) => {\n  const { client, ...options } = _options;\n  const sanity = useSanity(client);\n  const params = _params ? reactive(_params) : void 0;\n  if (params) {\n    options.watch = options.watch || [];\n    options.watch.push(params);\n  }\n  return useLazyAsyncData(\"sanity-\" + hash(query + (params ? JSON.stringify(params) : \"\")), () => sanity.fetch(query, params || {}), options);\n};\n","<template>\n\n    <transition name=\"fade\"\n    @before-enter=\"beforeEnter\"\n    @enter=\"enter\"\n    @leave=\"leave\">\n        <div v-if=\"loading\" class=\"bg-lightgrey md:bg-softwhite w-screen h-[100dvh] fixed top-0 left-0\">\n        </div>\n        <div v-else class=\"bg-lightgrey md:bg-softwhite\">\n            <div id=\"header-component\" class=\"bg-lightgrey md:bg-softwhite md:pointer-events-none\">\n                <Header></Header>\n            </div>\n            <figure id='background' class=\"pic bg-lightgrey md:bg-softwhite snap-start w-screen h-[100dvh] shrink-0\n            transition-opacity duration-500 md:duration-0\">\n                <img v-if=\"myData.cover_image\"\n                    :src=\"imageUrlFor(myData.cover_image)\"\n                    class=\"pic w-full h-full object-cover\"\n                />\n            </figure>\n        \n            <div v-if=\"!isMobile\" id=\"leftArrow\" class=\"arrow\"></div>\n            <div v-if=\"!isMobile\" id=\"rightArrow\" class=\"arrow\"></div>\n\n            <!-- @scroll.passive=\"onScroll\"\n            @mouseenter=\"handleMouseEnter\"\n            @mousemove=\"handleMouseMove\" -->\n            <div id='snapContainer' class=\"flex overflow-scroll absolute left-0 top-0 snap-mandatory snap-x\n            w-screen h-[100dvh] select-none\n            flex-col md:flex-row snap-y md:snap-x\"\n            ref=\"snapContainer\"\n            tabindex=\"0\"\n            \n            @scroll.passive=\"onScroll\"\n            @mousemove=\"handleMouseMove\" \n            @mouseleave=\"handleMouseLeave\"\n            @mouseenter=\"handleMouseEnter\"\n            @click=\"handleClick\"\n            >\n\n                <div class=\"overlay\" id=\"overlay\"></div>\n                <div id=\"empty\" class=\"slide active pic snap-start w-screen shrink-0\n                h-[100dvh] md:h-[100dvh]\"></div>\n\n                <div id='planimetria' class=\"slide relative grid-cols-2 pic snap-end shrink-0 bg-lightgrey\n                w-screen md:w-66% ml-0 md:ml-33% flex md:grid flex-col h-[100dvh] md:h-[100dvh]\n                snap-always\">\n                    <figure class=\"w-auto mx-20% bg-lightgrey mb-auto\n                    h-[50dvh] md:h-auto mt-[10dvh] md:mt-auto\">\n                        <img v-if=\"myData.planimetria\"\n                        :src=\"imageUrlFor(myData.planimetria)\"\n                        class=\"pic h-full m-auto object-contain mix-blend-multiply\n                        !w-auto !max-h-[80dvh]\"/>\n                    </figure>\n                    <div class=\"relative DM-Mono leading-tight\n                    w-auto md:w-[20rem] max-w-[80vw] md:max-w-[unset]\n                    ml-20px mb-20px md:m-auto md:mx-auto h-[40dvh] md:h-auto content-end md:content-auto\">\n                        <p class=\"text-base uppercase\" v-html=\"myData.title\" v-if=\"myData.title\"></p>\n                        <p class=\"text-s mt-4\" v-html=\"myData.citta\" v-if=\"myData.citta\"></p>\n                        <p class=\"text-s lg:text-base mt-8\" v-html=\"myData.description\" v-if=\"myData.description\"></p>\n                        <p class=\"text-s mt-6\" v-html=\"myData.altre_info\" v-if=\"myData.altre_info\"></p>\n                    </div>\n                </div>\n\n                <!-- DESKTOP -->\n                <div v-if=\"!isMobile\" v-for=\"slide in myImages.slides\" :key=\"slide._key\"\n                class=\"slide pic snap-start w-screen h-[100dvh] shrink-0 flex gap-20px items-end p-20px bg-softwhite\"\n                :class=\"[`place-content-${isContentCenter(slide.justify)}`],\n                    [`fixed-height-${isContentHeight(slide.fixed_height)}`]\">\n                    \n                    <figure class=\"pic h-auto\" v-for=\"imageObj in slide.images\" :key=\"imageObj._key\"\n                    v-bind=\"{\n                        alt_1: imageObj.image_2 ? imageUrlFor(imageObj.image_2) : undefined,\n                        ref: imageObj.image_2 ? 'originalImg' : undefined\n                        }\"\n                    :class=\"[`image-width-${getImageWidthClass(imageObj.image_width)}`,\n                        `mg-left-${getMargin(imageObj.margin_left)}`,\n                        `mg-right-${getMargin(imageObj.margin_right)}`,\n                        `mg-top-${getMarginTop(imageObj.margin_top)}`,\n                        `mg-bottom-${getMarginBottom(imageObj.margin_bottom)}`]\">\n                        <img v-if=\"imageObj.image.asset\"\n                        :src=\"imageUrlFor(imageObj.image.asset)\"\n                        class=\"pic object-cover\"\n                        />\n                    </figure>\n                </div>\n\n                <!-- MOBILE -->\n                <div v-if=\"isMobile\"\n                class=\"slide pic snap-start w-screen h-[100dvh] shrink-0 flex flex-col gap-20px items-end p-20px bg-lightgrey\n                overflow-y-scroll snap-always pt-16\">\n                    <template v-for=\"slide in myImages.slides\" :key=\"slide._key\">\n                        <figure class=\"pic h-auto\" v-for=\"imageObj in slide.images\" :key=\"imageObj._key\"\n                        v-bind=\"{\n                        alt_1: imageObj.image_2 ? imageUrlFor(imageObj.image_2) : undefined,\n                        ref: imageObj.image_2 ? 'originalImg' : undefined\n                        }\">\n                            <img v-if=\"imageObj.image.asset\"\n                            :src=\"imageUrlFor(imageObj.image.asset)\"\n                            class=\"pic object-cover\"\n                            />\n                        </figure>\n                    </template>\n                </div>\n\n            </div>\n        </div>\n    </transition>\n</template>\n\n<script setup>\nimport { onMounted, ref, nextTick, computed } from 'vue';\nimport { useWindowSize } from '@vueuse/core'\nimport sanity from \"../sanity/sanity.js\";\nimport imageUrlBuilder from \"@sanity/image-url\";\nimport { useRoute } from 'vue-router';\nimport { useMyStore } from '../store/store.js';\nimport $ from 'jquery';\n\nconst imageBuilder = imageUrlBuilder(sanity);\nconst route = useRoute();\nconst slug = route.params.slug;\n\nconst loading = ref(true);\nconst myImages = ref([]);\nconst myData = ref([]);\n\nconst store = useMyStore();\nlet isMobile = computed(() => store.isMobile)\n\nuseHead({\n    title: \"Cecilia Avogadro\",\n    meta: [{ name: \"description\", content: \"\" }],\n});\n\n// import store from '../store'\n\n//const otherQuery = `*[_type == \"project\" && slug.current == \"${slug}\"]`;\nconst otherQuery = `*[_type == \"project\" && slug.current == \"${slug}\"]{\n    _id,\n    _type,\n    title,\n    slug,\n    citta,\n    cover_image,\n    planimetria,\n    description,\n    altre_info,\n    slides[]{\n        _key,\n        _type,\n        title,\n        justify,\n        fixed_height,\n        images[]{\n            _key,\n            _type,\n            image{\n                asset->\n            },\n            image_2{\n                asset->\n            },\n            image_3{\n                asset->\n            },\n            image_width,\n            margin_left,\n            margin_right,\n            margin_top,\n            margin_bottom,\n        }\n    }\n}[0...50]`;\n\nconst imageUrlFor = (source) => {\n  return imageBuilder.image(source);\n  //console.log(source);\n};\n\nconst getImageWidthClass = (myData) => {\n    return myData.split('%')[0];\n    /* switch (imageWidth) {\n    case '10%':\n        return 'w-10';\n    case '30%':\n        return 'w-30';\n    default:\n        return '';\n    } */\n}\nconst getMargin = (myMargin) => {\n    if(myMargin){   \n        return String(myMargin).replaceAll('left-','').replaceAll('right-','');\n    } else {\n        return '20';\n    }\n}\nconst getMarginTop = (myMargin) => {\n    switch (myMargin) {\n        case 'top-0':\n            return 'no';\n        case 'top-20':\n            return '0';\n        case 'top-max':\n            return 'max';\n        default:\n            return '0';\n    }\n}\nconst getMarginBottom = (myMargin) => {\n    switch (myMargin) {\n        case 'bottom-0':\n            return 'no';\n        case 'bottom-20':\n            return '0';\n        case 'bottom-max':\n            return 'max';\n        default:\n            return '0';\n    }\n}\n\nconst isContentCenter = (justifyContentData) => {\n    switch (justifyContentData) {\n        case 'destra':\n            return 'end';\n        case 'sinistra':\n            return 'start';\n        case 'giustifica':\n            return 'justify';\n        default:\n            return 'center';\n    }\n};\n\nconst isContentHeight = (justifyContentData) => {\n    switch (justifyContentData) {\n        case '60%':\n            return '60';\n        case '70%':\n            return '70';\n        case '80%':\n            return '80';\n        case 'max':\n            return 'max';\n        default:\n            return 'auto';\n    }\n};\n\nconst fetchData = () => {\n    loading.value = true;\n    sanity.fetch(otherQuery).then(\n        (data) => {\n            //console.log('ccc', data[0]);\n            loading.value = false;\n            myImages.value = data[0];\n            myData.value = data[0];\n\n            //console.log('aaa', isContentCenter(data[0].slides.justify));\n        },\n        (error) => {\n            loading.value = false;\n            console.error(error);\n        }\n    );\n};\nonMounted(() => {\n    fetchData();\n    console.log(snapContainer)\n    setTimeout(() => {\n        if(isMobile.value){return}\n        snapContainer.value.focus();\n    }, 100);\n});\nconst query = groq`*[_type == \"project\" && slug.current == \"${slug}\"]`;\nconst { data } = useSanityQuery(query);\n//console.log(\"data:\", data);\n\n\n\n\n\n\n\nfunction onScroll(event) {\n    //handleMouseMove();\n\n    const { width, height } = useWindowSize();\n    let firstSlide = document.getElementById('planimetria')\n\n    if(!isMobile.value){\n        if (firstSlide.getBoundingClientRect().left < 0) {\n            document.querySelector('#background').classList.add('opacity-0');\n        } else if (firstSlide.getBoundingClientRect().left <= (width._value / 3)) {\n            document.querySelectorAll('#head a:not(.text-black)').forEach(span => {\n                span.classList.add('text-black');\n            });\n            document.querySelector('#background').classList.remove('opacity-0');\n        } else if (firstSlide.getBoundingClientRect().left <= ((width._value / 3)*2 + 10)) {\n            document.querySelectorAll('#head a:not(.menu).text-black').forEach(span => {\n                span.classList.remove('text-black');\n            });\n            document.querySelectorAll('#head a.menu:not(.text-black)').forEach(span => {\n                span.classList.add('text-black');\n            });\n        } else {\n            document.querySelectorAll('#head a.text-black').forEach(span => {\n                span.classList.remove('text-black');\n            });\n        }\n\n        //START GIF\n        if(document.querySelectorAll('figure[alt_1]')){\n        //if(originalImg){\n            /* if(!intervalIsSetted && document.querySelector('figure[alt_1]').getBoundingClientRect().left > 0\n            && document.querySelector('figure[alt_1]').getBoundingClientRect().left < (width._value)){\n                //changeGifImg(mouseX, width._value);\n                interval = setInterval(function() {changeGifImg(true, true)}, 2000);\n                intervalIsSetted = true;\n            } */\n            document.querySelectorAll('figure[alt_1]').forEach(imageGIF => {\n                if(!intervalIsSetted && imageGIF.getBoundingClientRect().left > 0){\n                    //&& imageGIF.getBoundingClientRect().left < (width._value) + 10\n                    //changeGifImg(mouseX, width._value);\n                    interval = setInterval(function() {changeGifImg(true, true)}, 2000);\n                    intervalIsSetted = true;\n                }\n            })\n        }\n    } else if(isMobile.value){\n        if (firstSlide.getBoundingClientRect().top <= (height._value / 10)) {\n            document.querySelector('#homeLinkMobile').classList.add('text-black');\n            document.querySelector('#menuButtonMobile').classList.add('text-black');\n            document.querySelector('#background').classList.add('opacity-0');\n        } else {\n            document.querySelector('#homeLinkMobile').classList.remove('text-black');\n            document.querySelector('#menuButtonMobile').classList.remove('text-black');\n            document.querySelector('#background').classList.remove('opacity-0');\n        }\n    }\n\n    \n\n    \n    /* let GIFs = document.querySelectorAll('figure[alt_1]');\n    if(GIFs.length > 0){\n        const originalImgSrc = GIFs[0].getElementsByTagName('img')[0].src;\n        if(!store.myUrlSaved){\n            store.myUrl_1 = originalImgSrc;\n            store.myUrl_2 = GIFs[0].getElementsByTagName('img')[0].parentElement.getAttribute('alt_1');\n            store.myUrlSaved = true;\n        }\n        if((GIFs.length > 0)&&(GIFs[0].getBoundingClientRect().left > (width._value / 2)&&(GIFs[0].classList.contains('changed')))) {\n            GIFs[0].classList.remove('changed')\n            GIFs[0].getElementsByTagName('img')[0].src = store.myUrl_1;\n        } else if((GIFs.length > 0)&&(GIFs[0].getBoundingClientRect().left <= (width._value / 2)&&(!GIFs[0].classList.contains('changed')))) {\n            GIFs[0].classList.add('changed')\n            GIFs[0].getElementsByTagName('img')[0].src = store.myUrl_2;\n        }\n    } */\n}\n\n\nconst originalImg = ref(null) \nfunction changeGifImg(mousePosition, width) {\n    let GIFs = document.querySelectorAll('figure[alt_1]');\n\n    if(GIFs.length > 1){\n        const originalImgSrc = GIFs[0].getElementsByTagName('img')[0].src;\n        const originalImgSrc2 = GIFs[1].getElementsByTagName('img')[0].src;\n        if(!store.myUrlSaved){\n            store.myUrl_1 = originalImgSrc;\n            store.myUrl_2 = GIFs[0].getElementsByTagName('img')[0].parentElement.getAttribute('alt_1');\n            store.myUrlSaved = true;\n\n            store.myUrl_1_2 = originalImgSrc2;\n            store.myUrl_2_2 = GIFs[1].getElementsByTagName('img')[0].parentElement.getAttribute('alt_1');\n            store.myUrlSaved2 = true;\n        }\n        if((GIFs.length > 0)&&(GIFs[0].classList.contains('changed'))) {\n            GIFs[0].classList.remove('changed')\n            GIFs[0].getElementsByTagName('img')[0].src = store.myUrl_1;\n\n            GIFs[1].classList.remove('changed')\n            GIFs[1].getElementsByTagName('img')[0].src = store.myUrl_1_2;\n\n        } else if((GIFs.length > 0)&&(!GIFs[0].classList.contains('changed'))) {\n            GIFs[0].classList.add('changed')\n            GIFs[0].getElementsByTagName('img')[0].src = store.myUrl_2;\n            GIFs[1].classList.add('changed')\n            GIFs[1].getElementsByTagName('img')[0].src = store.myUrl_2_2;\n        } \n    } else if(GIFs.length > 0){\n        const originalImgSrc = GIFs[0].getElementsByTagName('img')[0].src;\n        if(!store.myUrlSaved){\n            store.myUrl_1 = originalImgSrc;\n            store.myUrl_2 = GIFs[0].getElementsByTagName('img')[0].parentElement.getAttribute('alt_1');\n            store.myUrlSaved = true;\n        }\n        if((GIFs.length > 0)&&(GIFs[0].classList.contains('changed'))) {\n            GIFs[0].classList.remove('changed')\n            GIFs[0].getElementsByTagName('img')[0].src = store.myUrl_1;\n        } else if((GIFs.length > 0)&&(!GIFs[0].classList.contains('changed'))) {\n            GIFs[0].classList.add('changed')\n            GIFs[0].getElementsByTagName('img')[0].src = store.myUrl_2;\n        } \n    }\n}\n\n\nlet intervalIsSetted = false;\nlet interval;\nconst handleMouseEnter = (event) => {\n    handleMouseMove(event);\n};\nconst handleMouseMove = (event) => {\n    \n    if(isMobile.value){return}\n\n    const container = event.currentTarget;\n    const mouseX = event.clientX;\n    const mouseY = event.clientY;\n\n    document.documentElement.style.setProperty('--mouse-x', `${mouseX}px`);\n    document.documentElement.style.setProperty('--mouse-y', `${mouseY}px`);\n\n    const containerWidth = container.offsetWidth;\n    if (mouseX < containerWidth / 2) {\n        document.querySelector('#leftArrow').classList.add('visible');\n        document.querySelector('#rightArrow').classList.remove('visible');\n    } else {\n        document.querySelector('#leftArrow').classList.remove('visible');\n        document.querySelector('#rightArrow').classList.add('visible');\n    }\n\n    const { width, height } = useWindowSize();\n};\n\nconst handleMouseLeave = () => {\n    if(isMobile.value){return}\n    document.querySelector('#leftArrow').classList.remove('visible');\n    document.querySelector('#rightArrow').classList.remove('visible');\n};\n\n\n\n\n//VANILLA JS\nconst handleClick = (event) => {\n    event.preventDefault();\n\n    const container = event.currentTarget;\n    const mouseX = event.clientX - container.getBoundingClientRect().left;\n    const containerWidth = container.offsetWidth;\n\n    const slides = Array.from(container.children).filter(child => child.classList.contains('slide'));\n    const currentIndex = slides.findIndex(slide => slide.getBoundingClientRect().left >= container.getBoundingClientRect().left - 10);\n\n    let nextIndex;\n    if (mouseX < containerWidth / 2) {\n        nextIndex = currentIndex > 0 ? currentIndex - 1 : slides.length - 1;\n    } else {\n        nextIndex = currentIndex < slides.length - 1 ? currentIndex + 1 : 0;\n    }\n\n    setTimeout(() => {\n        if (mouseX < containerWidth / 2) {\n            if (currentIndex > 0) {\n                slides[currentIndex - 1].scrollIntoView({ behavior: 'smooth', inline: 'start' });\n            } else {\n                slides[slides.length - 1].scrollIntoView({ behavior: 'smooth', inline: 'start' });\n            }\n        } else {\n            if (currentIndex < slides.length - 1) {\n                slides[currentIndex + 1].scrollIntoView({ behavior: 'smooth', inline: 'start' });\n            } else {\n                slides[0].scrollIntoView({ behavior: 'smooth', inline: 'start' });\n            }\n        }\n\n    }, 100);\n};\n//JQUERY\n/* const handleClick = (event) => {\n    event.preventDefault();\n\n    const $container = $(event.currentTarget);\n    const mouseX = event.clientX - $container.offset().left;\n    const containerWidth = $container.width();\n    const viewportWidth = $(window).width();\n    const containerScrollLeft = $container.scrollLeft();\n    const containerScrollWidth = $container[0].scrollWidth;\n    const $slides = $container.children('.slide');\n\n    // Check if the scrolling animation is already in progress\n    if ($container.is(':animated')) return;\n\n    // Determine the direction and calculate the new scroll position\n    let newScrollLeft;\n    if (mouseX < containerWidth / 2) {\n        // Scroll left\n        if (containerScrollLeft <= 0) {\n            // If at the start, jump to the end\n            newScrollLeft = containerScrollWidth - containerWidth;\n        } else {\n            // Otherwise, scroll by viewport width\n            newScrollLeft = Math.max(containerScrollLeft - viewportWidth, 0);\n        }\n    } else {\n        // Scroll right\n        if (containerScrollLeft + containerWidth >= containerScrollWidth) {\n            // If at the end, jump to the start\n            newScrollLeft = 0;\n        } else {\n            // Otherwise, scroll by viewport width\n            newScrollLeft = Math.min(containerScrollLeft + viewportWidth, containerScrollWidth - containerWidth);\n        }\n    }\n\n    // Remove the scroll snap class\n    $container.removeClass('snap-mandatory');\n\n    // Animate scrolling\n    $container.animate({ scrollLeft: newScrollLeft }, 500, function() {\n        // Add the scroll snap class back after the animation completes\n        $container.addClass('snap-mandatory');\n    });\n}; */\n\n\n\n//VERTICAL SCROLL\nconst snapContainer = ref(null);\nlet scrollTimeout;\n\n/* setTimeout(() => {\n    if (snapContainer.value) {\n        let container = snapContainer._value;\n\n        // Horizontal scroll on vertical scroll\n        container.addEventListener('wheel', function(e) {\n            if (e.deltaY !== 0) {\n                container.scrollLeft += e.deltaY;\n                e.preventDefault();\n            }\n\n            // Reset the timeout on every scroll\n            clearTimeout(scrollTimeout);\n\n            // Set a timeout to run after the user stops scrolling\n            scrollTimeout = setTimeout(() => {\n                snapToMostVisibleSlide(container);\n            }, 100); // Adjust the delay as needed\n        });\n    }\n}, 100); */\n\n// Function to calculate the most visible slide and snap to the right margin\nfunction snapToMostVisibleSlide(container) {\n    const slides = container.querySelectorAll('.slide');\n    let mostVisibleSlide = null;\n    let maxVisibleArea = 0;\n\n    slides.forEach(slide => {\n        const rect = slide.getBoundingClientRect();\n        const visibleArea = Math.max(0, Math.min(rect.right, container.clientWidth) - Math.max(rect.left, 0));\n\n        if (visibleArea > maxVisibleArea) {\n            maxVisibleArea = visibleArea;\n            mostVisibleSlide = slide;\n        }\n    });\n\n    if (mostVisibleSlide) {\n        // Calculate the scroll position needed to align the right edge of the slide with the right edge of the container\n        const scrollPosition = mostVisibleSlide.offsetLeft - (container.clientWidth - mostVisibleSlide.offsetWidth);\n        container.scrollTo({\n            left: scrollPosition,\n            behavior: 'smooth'\n        });\n    }\n}\n\n\n/* const snapContainer = ref(null);\nonMounted(async () => {\n    \n    setTimeout(() => {\n        if (snapContainer.value) {\n            snapContainer.value.addEventListener('wheel', (ev) => {\n                if (ev.deltaY !== 0) {\n                    ev.preventDefault();\n                    snapContainer.value.scrollLeft += ev.deltaY;\n\n                    // Debugging output\n                    console.log(\n                        'Scroll Amount (Vertical):', ev.deltaY,\n                        'Current ScrollLeft:', snapContainer.value.scrollLeft\n                    );\n                }\n            });\n        } else {\n        console.error('snapContainer.value is null');\n        }\n    }, 100); // 100 ms delay to ensure DOM updates\n}); */\n\n</script>\n\n\n\n<script>\n\nexport default {\n  methods: {\n    beforeEnter(el) {\n      el.style.opacity = 0;\n    },\n    enter(el, done) {\n      el.offsetHeight; // Trigger reflow\n      el.style.transition = 'opacity 0.5s';\n      el.style.opacity = 1;\n      done();\n    },\n    leave(el, done) {\n      el.style.transition = 'opacity 0.5s';\n      el.style.opacity = 0;\n      done();\n    },\n    imageUrlFor(image) {\n      // Define your method to generate image URL\n      return `path/to/images/${image}`;\n    }\n  }\n};\n</script>"],"version":3}