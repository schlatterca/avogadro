import { defu } from "defu";
import { hash } from "ohash";
import { onScopeDispose, reactive, ref } from "vue";
import { createQueryStore as createCoreQueryStore } from "@sanity/core-loader";
import { defineEncodeDataAttribute } from "@sanity/core-loader/encode-data-attribute";
import { enableVisualEditing } from "@sanity/visual-editing";
import { createSanityClient, useNuxtApp, useRuntimeConfig, useAsyncData, useRouter, useState, reloadNuxtApp } from "#imports";
const createQueryStore = (visualEditing, client, tag) => {
  const queryStore = createCoreQueryStore({
    tag: tag || "nuxt-loader",
    client: false,
    ssr: true
  });
  if (import.meta.server) {
    const serverClient = client.withConfig({
      perspective: "previewDrafts",
      token: visualEditing?.token,
      useCdn: false
    });
    queryStore.setServerClient(serverClient);
  }
  return queryStore;
};
const createSanityHelper = (options) => {
  const config = { ...options };
  const { visualEditing, ...clientConfig } = config;
  let client = createSanityClient(clientConfig);
  const visualEditingState = useSanityVisualEditingState();
  const visualEditingEnabled = visualEditing && (!visualEditing.previewMode || visualEditingState.enabled);
  let queryStore = visualEditingEnabled ? createQueryStore(visualEditing, client) : void 0;
  return {
    client,
    config,
    // @ts-expect-error untyped args
    fetch: (...args) => client.fetch(...args),
    queryStore,
    setToken(token) {
      config.token = token;
      client = createSanityClient(clientConfig);
      if (queryStore && visualEditing) {
        queryStore = createQueryStore(visualEditing, client);
      }
    }
  };
};
export const useSanityVisualEditingState = () => {
  const enabled = useState("_sanity_visualEditing", () => false);
  return reactive({
    enabled,
    inFrame: isInFrame()
  });
};
const isInFrame = () => {
  if (import.meta.server)
    return void 0;
  return !!(window.self !== window.top || window.opener);
};
export const useSanity = (client = "default") => {
  const nuxtApp = useNuxtApp();
  if (nuxtApp._sanity?.[client]) {
    return nuxtApp._sanity[client];
  }
  nuxtApp._sanity = nuxtApp._sanity || {};
  const $config = useRuntimeConfig();
  const { additionalClients = {}, visualEditing, ...options } = import.meta.client ? $config.public.sanity : defu(
    $config.sanity,
    $config.public.sanity
  );
  if (client === "default") {
    nuxtApp._sanity.default = createSanityHelper({
      ...options,
      visualEditing: visualEditing || void 0
    });
    return nuxtApp._sanity.default;
  }
  nuxtApp._sanity[client] = createSanityHelper(
    defu(additionalClients[client], options)
  );
  return nuxtApp._sanity[client];
};
export const useSanityQuery = (query, _params, _options = {}) => {
  const { client, perspective: _perspective, ...options } = _options;
  const sanity = useSanity(client);
  const params = _params ? reactive(_params) : void 0;
  if (params) {
    options.watch = options.watch || [];
    options.watch.push(params);
  }
  const perspective = _perspective || sanity.queryStore ? "previewDrafts" : "published";
  const queryKey = "sanity-" + hash(query + (params ? JSON.stringify(params) : ""));
  const data = ref(null);
  const sourceMap = ref(null);
  const encodeDataAttribute = ref(() => {
  });
  const updateRefs = (newData, newSourceMap) => {
    data.value = newData;
    sourceMap.value = newSourceMap || null;
    encodeDataAttribute.value = defineEncodeDataAttribute(
      newData,
      newSourceMap,
      sanity.config.visualEditing?.studioUrl
    );
  };
  let result;
  if (!sanity.queryStore) {
    result = useAsyncData(
      queryKey,
      async () => {
        const data2 = await sanity.fetch(query, params || {}, { perspective });
        return { data: data2 };
      },
      options
    );
  } else {
    let unsubscribe = () => {
    };
    const setupFetcher = (cb) => {
      unsubscribe();
      const fetcher = sanity.queryStore.createFetcherStore(
        query,
        _params,
        void 0
      );
      unsubscribe = fetcher.subscribe((newSnapshot) => {
        if (newSnapshot.data) {
          updateRefs(newSnapshot.data, newSnapshot.sourceMap);
          cb?.(newSnapshot);
        }
      });
    };
    const proxyClient = {
      fetch: (query2, params2, options2) => $fetch(sanity.config.visualEditing.proxyEndpoint, {
        method: "POST",
        body: { query: query2, params: params2, options: options2 }
      })
    };
    result = useAsyncData(
      queryKey,
      async () => {
        const client2 = import.meta.server ? sanity.queryStore.unstable__serverClient.instance || sanity.client : proxyClient;
        const { result: data2, resultSourceMap: sourceMap2 } = await client2.fetch(query, params || {}, {
          perspective,
          filterResponse: false,
          resultSourceMap: "withKeyArraySelector"
        });
        return sourceMap2 ? { data: data2, sourceMap: sourceMap2 } : { data: data2 };
      },
      options
    );
    if (import.meta.client) {
      setupFetcher();
    }
    onScopeDispose(unsubscribe);
  }
  return Object.assign(new Promise((resolve) => {
    result.then((value) => {
      updateRefs(value.data.value.data, value.data.value.sourceMap);
      resolve({
        ...result,
        data,
        sourceMap,
        encodeDataAttribute
      });
    });
  }), { ...result, data, sourceMap, encodeDataAttribute });
};
export function useSanityLiveMode(options) {
  const { client = "default" } = options || {};
  let disable = () => {
  };
  if (import.meta.client) {
    const sanity = useSanity(client);
    if (sanity.queryStore) {
      disable = sanity.queryStore.enableLiveMode({
        client: sanity.client
      });
    }
  }
  onScopeDispose(disable);
  return disable;
}
export function useSanityVisualEditing(options = {}) {
  const { zIndex, refresh } = options;
  let disable = () => {
  };
  if (import.meta.client) {
    const router = useRouter();
    disable = enableVisualEditing({
      zIndex,
      // It is unlikely this API will be used as much by Nuxt users, as
      // implementing fully fledged visual editing is more straightforward
      // compared with other frameworks
      refresh: (payload) => {
        function refreshDefault() {
          if (payload.source === "mutation" && payload.livePreviewEnabled) {
            return false;
          }
          return new Promise((resolve) => {
            reloadNuxtApp({ ttl: 1e3 });
            resolve();
          });
        }
        return refresh ? refresh(payload, refreshDefault) : refreshDefault();
      },
      history: {
        subscribe: (navigate) => {
          router.isReady().then(() => {
            navigate({
              type: "replace",
              url: router.currentRoute.value.fullPath
            });
          });
          return router.afterEach((to) => {
            navigate({ type: "push", url: to.fullPath });
          });
        },
        update: (update) => {
          if (update.type === "push" || update.type === "replace") {
            router[update.type](update.url);
          } else if (update.type === "pop") {
            router.back();
          }
        }
      }
    });
  }
  onScopeDispose(disable);
  return disable;
}
