import {Cache as Cache_2} from 'async-cache-dedupe'
import type {ClientPerspective} from '@sanity/client'
import type {ContentSourceMap} from '@sanity/client'
import type {QueryParams} from '@sanity/client'
import type {SanityClient} from '@sanity/client'
import type {SanityStegaClient} from '@sanity/client/stega'
import type {StegaConfig} from '@sanity/client/stega'
import type {StudioPathLike} from '@sanity/client/csm'

declare type AllKeys<T> = T extends any ? keyof T : never

export {ContentSourceMap}

/** @public */
export declare const createQueryStore: (options: CreateQueryStoreOptions) => QueryStore

/** @public */
export declare interface CreateQueryStoreOptions {
  /**
   * The Sanity client to use for fetching data, or `false` if `ssr: true` and it's set with `setServerClient` later
   * You may use any client that is an `instanceof SanityClient` or `instanceof SanityStegaClient`.
   * @example `import {createClient} from '@sanity/client'`
   * @example `import {createClient} from '@sanity/client/stega'`
   * @example `import {createClient} from '@sanity/preview-kit/client'`
   * @example `import {createClient} from 'next-sanity'`
   */
  client: SanityClient | SanityStegaClient | false
  /**
   * If you want all data fetching to be done server-side in production, set this to `true` and `client: false`.
   * Then, in your server entry file, you can set the Sanity client with `setServerClient`.
   */
  ssr?: boolean
  /** @internal */
  tag?: string
}

/** @public */
export declare type EnableLiveMode = (options: EnableLiveModeOptions) => () => void

/** @public */
export declare interface EnableLiveModeOptions {
  /**
   * @deprecated -- no longer needed
   */
  allowStudioOrigin?: 'same-origin' | `https://${string}` | `http://${string}` | string
  /**
   * You may use any client that is an `instanceof SanityClient` or `instanceof SanityStegaClient`.
   * Required when `ssr: true`, optional otherwise.
   * @example `import {createClient} from '@sanity/client'`
   * @example `import {createClient} from '@sanity/client/stega'`
   * @example `import {createClient} from '@sanity/preview-kit/client'`
   * @example `import {createClient} from 'next-sanity'`
   */
  client?: SanityClient | SanityStegaClient
  /**
   * Fires when a connection is established to a parent Studio window.
   */
  onConnect?: () => void
  /**
   * Fires when a connection is established to a parent Studio window and then lost.
   */
  onDisconnect?: () => void
}

/**
 * Creates a encoded payload suitable for passing to a `data-sanity` attribute, which are used by `@sanity/visual-editing`
 * @public
 */
export declare type EncodeDataAttribute<QueryResponseResult = unknown> = (
  result: QueryResponseResult,
  sourceMap: ContentSourceMap | undefined,
  studioUrl: Exclude<StegaConfig['studioUrl'], undefined> | undefined,
  path: StudioPathLike,
) => string | undefined

/** @internal */
export declare interface Fetcher {
  hydrate: <QueryResponseResult, QueryResponseError>(
    query: string,
    params: QueryParams,
    initial?: Pick<
      QueryStoreState<QueryResponseResult, QueryResponseError>,
      'data' | 'sourceMap' | 'perspective'
    >,
  ) => QueryStoreState<QueryResponseResult, QueryResponseError>
  fetch: <QueryResponseResult, QueryResponseError>(
    query: string,
    params: QueryParams,
    $fetch: MapStore<QueryStoreState<QueryResponseResult, QueryResponseError>>,
    controller: AbortController,
  ) => void
}

declare type Get<T, K extends KeyofBase> = Extract<T, {[K1 in K]: any}>[K]

declare type KeyofBase = keyof any

export declare interface MapStore<Value extends object = any> extends WritableAtom<Value> {
  /**
   * Subscribe to store changes.
   *
   * In contrast with {@link Store#subscribe} it do not call listener
   * immediately.
   *
   * @param listener Callback with store value and old value.
   * @param changedKey Key that was changed. Will present only if `setKey`
   *                   has been used to change a store.
   * @returns Function to remove listener.
   */
  listen(
    listener: (
      value: ReadonlyIfObject<Value>,
      oldValue: ReadonlyIfObject<Value>,
      changedKey: AllKeys<Value>,
    ) => void,
  ): () => void

  /**
   * Change store value.
   *
   * ```js
   * $settings.set({ theme: 'dark' })
   * ```
   *
   * Operation is atomic, subscribers will be notified once with the new value.
   * `changedKey` will be undefined
   *
   * @param newValue New store value.
   */
  set(newValue: Value): void

  /**
   * Change key in store value.
   *
   * ```js
   * $settings.setKey('theme', 'dark')
   * ```
   *
   * To delete key set `undefined`.
   *
   * ```js
   * $settings.setKey('theme', undefined)
   * ```
   *
   * @param key The key name.
   * @param value New value.
   */
  setKey<Key extends AllKeys<Value>>(key: Key, value: Get<Value, Key> | Value[Key]): void

  /**
   * Subscribe to store changes and call listener immediately.
   *
   * ```
   * import { $router } from '../store'
   *
   * $router.subscribe(page => {
   *   console.log(page)
   * })
   * ```
   *
   * @param listener Callback with store value and old value.
   * @param changedKey Key that was changed. Will present only
   *                   if `setKey` has been used to change a store.
   * @returns Function to remove listener.
   */
  subscribe(
    listener: (
      value: ReadonlyIfObject<Value>,
      oldValue: ReadonlyIfObject<Value> | undefined,
      changedKey: AllKeys<Value> | undefined,
    ) => void,
  ): () => void
}

declare type Primitive = boolean | number | string

export {QueryParams}

/** @public */
export declare interface QueryStore {
  createFetcherStore: <QueryResponseResult = unknown, QueryResponseError = unknown>(
    query: string,
    params?: QueryParams,
    /**
     * Initial `data` and `sourceMap`, used with SSR hydration and is required if `ssr: true`
     * and an optional speed optimization if `ssr: false`
     */
    initial?: {
      data: QueryResponseResult
      sourceMap?: ContentSourceMap
      perspective?: ClientPerspective
    },
  ) => MapStore<QueryStoreState<QueryResponseResult, QueryResponseError>>
  /**
   * When `ssr: true` you call this in your server entry point that imports the result of `createQueryStore` instance.
   * It's required to call it before any data fetching is done.
   */
  setServerClient: (client: SanityClient | SanityStegaClient) => void
  enableLiveMode: EnableLiveMode
  /** @internal */
  unstable__cache: {
    instance: Cache_2 & {
      fetch: <QueryResponseResult>(key: string) => Promise<{
        result: QueryResponseResult
        resultSourceMap: ContentSourceMap | undefined
      }>
    }
  }
  /** @internal */
  unstable__serverClient: {
    /**
     * Only set if `ssr: true` and `setServerClient` has been called.
     */
    instance: SanityClient | undefined
    /**
     * Will be `true` if the client given to `setServerClient` has a token configured.
     */
    canPreviewDrafts?: boolean
  }
}

/** @public */
export declare interface QueryStoreState<QueryResponseResult, QueryResponseError> {
  loading: boolean
  error?: QueryResponseError
  data?: QueryResponseResult
  sourceMap?: ContentSourceMap
  perspective?: ClientPerspective
}

/**
 * Store object.
 */
declare interface ReadableAtom<Value = any> {
  /**
   * Get store value.
   *
   * In contrast with {@link ReadableAtom#value} this value will be always
   * initialized even if store had no listeners.
   *
   * ```js
   * $store.get()
   * ```
   *
   * @returns Store value.
   */
  get(): Value

  /**
   * Listeners count.
   */
  readonly lc: number

  /**
   * Subscribe to store changes.
   *
   * In contrast with {@link Store#subscribe} it do not call listener
   * immediately.
   *
   * @param listener Callback with store value and old value.
   * @returns Function to remove listener.
   */
  listen(
    listener: (value: ReadonlyIfObject<Value>, oldValue: ReadonlyIfObject<Value>) => void,
  ): () => void

  /**
   * Unbind all listeners.
   */
  off(): void

  /**
   * Subscribe to store changes and call listener immediately.
   *
   * ```
   * import { $router } from '../store'
   *
   * $router.subscribe(page => {
   *   console.log(page)
   * })
   * ```
   *
   * @param listener Callback with store value and old value.
   * @returns Function to remove listener.
   */
  subscribe(
    listener: (value: ReadonlyIfObject<Value>, oldValue?: ReadonlyIfObject<Value>) => void,
  ): () => void

  /**
   * Low-level method to read storeâ€™s value without calling `onStart`.
   *
   * Try to use only {@link ReadableAtom#get}.
   * Without subscribers, value can de undefined.
   */
  readonly value: undefined | Value
}

declare type ReadonlyIfObject<Value> = Value extends undefined
  ? Value
  : Value extends (...args: any) => any
    ? Value
    : Value extends Primitive
      ? Value
      : Value extends object
        ? Readonly<Value>
        : Value

/** @internal */
export declare const runtime: string

/** @internal */
export declare type SetFetcher = (fetcher: Fetcher) => () => void

/**
 * Store with a way to manually change the value.
 */
export declare interface WritableAtom<Value = any> extends ReadableAtom<Value> {
  /**
   * Change store value.
   *
   * ```js
   * $router.set({ path: location.pathname, page: parse(location.pathname) })
   * ```
   *
   * @param newValue New store value.
   */
  set(newValue: Value): void
}

export {}
