{"version":3,"file":"index.js","sources":["../../../../node_modules/.pnpm/async-cache-dedupe@2.2.0/node_modules/async-cache-dedupe/src/symbol.js","../../../../node_modules/.pnpm/safe-stable-stringify@2.4.3/node_modules/safe-stable-stringify/index.js","../../../../node_modules/.pnpm/async-cache-dedupe@2.2.0/node_modules/async-cache-dedupe/src/util.js","../../../../node_modules/.pnpm/async-cache-dedupe@2.2.0/node_modules/async-cache-dedupe/src/storage/interface.js","../../../../node_modules/.pnpm/obliterator@2.0.4/node_modules/obliterator/iterator.js","../../../../node_modules/.pnpm/obliterator@2.0.4/node_modules/obliterator/support.js","../../../../node_modules/.pnpm/obliterator@2.0.4/node_modules/obliterator/foreach.js","../../../../node_modules/.pnpm/mnemonist@0.39.8/node_modules/mnemonist/utils/typed-arrays.js","../../../../node_modules/.pnpm/mnemonist@0.39.8/node_modules/mnemonist/utils/iterables.js","../../../../node_modules/.pnpm/mnemonist@0.39.8/node_modules/mnemonist/lru-cache.js","../../../../node_modules/.pnpm/async-cache-dedupe@2.2.0/node_modules/async-cache-dedupe/src/storage/memory.js","../../../../node_modules/.pnpm/async-cache-dedupe@2.2.0/node_modules/async-cache-dedupe/src/storage/index.js","../../../../node_modules/.pnpm/async-cache-dedupe@2.2.0/node_modules/async-cache-dedupe/src/storage/redis.js","../../../../node_modules/.pnpm/async-cache-dedupe@2.2.0/node_modules/async-cache-dedupe/src/cache.js","../../../../node_modules/.pnpm/async-cache-dedupe@2.2.0/node_modules/async-cache-dedupe/index.js","../../../../node_modules/.pnpm/nanostores@0.10.3/node_modules/nanostores/task/index.js","../../../../node_modules/.pnpm/nanostores@0.10.3/node_modules/nanostores/clean-stores/index.js","../../../../node_modules/.pnpm/nanostores@0.10.3/node_modules/nanostores/atom/index.js","../../src/env.ts","../../src/index.ts","../../src/live-mode/index.ts","../../../../node_modules/.pnpm/nanostores@0.10.3/node_modules/nanostores/map/index.js","../../../../node_modules/.pnpm/nanostores@0.10.3/node_modules/nanostores/lifecycle/index.js"],"sourcesContent":["'use strict'\n\nconst kValues = Symbol('values')\nconst kStorage = Symbol('kStorage')\nconst kStorages = Symbol('kStorages')\nconst kTransfromer = Symbol('kTransformer')\nconst kTTL = Symbol('kTTL')\nconst kOnDedupe = Symbol('kOnDedupe')\nconst kOnError = Symbol('kOnError')\nconst kOnHit = Symbol('kOnHit')\nconst kOnMiss = Symbol('kOnMiss')\nconst kStale = Symbol('kStale')\n\nmodule.exports = { kValues, kStorage, kStorages, kTransfromer, kTTL, kOnDedupe, kOnError, kOnHit, kOnMiss, kStale }\n","'use strict'\n\nconst { hasOwnProperty } = Object.prototype\n\nconst stringify = configure()\n\n// @ts-expect-error\nstringify.configure = configure\n// @ts-expect-error\nstringify.stringify = stringify\n\n// @ts-expect-error\nstringify.default = stringify\n\n// @ts-expect-error used for named export\nexports.stringify = stringify\n// @ts-expect-error used for named export\nexports.configure = configure\n\nmodule.exports = stringify\n\n// eslint-disable-next-line no-control-regex\nconst strEscapeSequencesRegExp = /[\\u0000-\\u001f\\u0022\\u005c\\ud800-\\udfff]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?:[^\\ud800-\\udbff]|^)[\\udc00-\\udfff]/\n\n// Escape C0 control characters, double quotes, the backslash and every code\n// unit with a numeric value in the inclusive range 0xD800 to 0xDFFF.\nfunction strEscape (str) {\n  // Some magic numbers that worked out fine while benchmarking with v8 8.0\n  if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {\n    return `\"${str}\"`\n  }\n  return JSON.stringify(str)\n}\n\nfunction insertSort (array) {\n  // Insertion sort is very efficient for small input sizes but it has a bad\n  // worst case complexity. Thus, use native array sort for bigger values.\n  if (array.length > 2e2) {\n    return array.sort()\n  }\n  for (let i = 1; i < array.length; i++) {\n    const currentValue = array[i]\n    let position = i\n    while (position !== 0 && array[position - 1] > currentValue) {\n      array[position] = array[position - 1]\n      position--\n    }\n    array[position] = currentValue\n  }\n  return array\n}\n\nconst typedArrayPrototypeGetSymbolToStringTag =\n  Object.getOwnPropertyDescriptor(\n    Object.getPrototypeOf(\n      Object.getPrototypeOf(\n        new Int8Array()\n      )\n    ),\n    Symbol.toStringTag\n  ).get\n\nfunction isTypedArrayWithEntries (value) {\n  return typedArrayPrototypeGetSymbolToStringTag.call(value) !== undefined && value.length !== 0\n}\n\nfunction stringifyTypedArray (array, separator, maximumBreadth) {\n  if (array.length < maximumBreadth) {\n    maximumBreadth = array.length\n  }\n  const whitespace = separator === ',' ? '' : ' '\n  let res = `\"0\":${whitespace}${array[0]}`\n  for (let i = 1; i < maximumBreadth; i++) {\n    res += `${separator}\"${i}\":${whitespace}${array[i]}`\n  }\n  return res\n}\n\nfunction getCircularValueOption (options) {\n  if (hasOwnProperty.call(options, 'circularValue')) {\n    const circularValue = options.circularValue\n    if (typeof circularValue === 'string') {\n      return `\"${circularValue}\"`\n    }\n    if (circularValue == null) {\n      return circularValue\n    }\n    if (circularValue === Error || circularValue === TypeError) {\n      return {\n        toString () {\n          throw new TypeError('Converting circular structure to JSON')\n        }\n      }\n    }\n    throw new TypeError('The \"circularValue\" argument must be of type string or the value null or undefined')\n  }\n  return '\"[Circular]\"'\n}\n\nfunction getBooleanOption (options, key) {\n  let value\n  if (hasOwnProperty.call(options, key)) {\n    value = options[key]\n    if (typeof value !== 'boolean') {\n      throw new TypeError(`The \"${key}\" argument must be of type boolean`)\n    }\n  }\n  return value === undefined ? true : value\n}\n\nfunction getPositiveIntegerOption (options, key) {\n  let value\n  if (hasOwnProperty.call(options, key)) {\n    value = options[key]\n    if (typeof value !== 'number') {\n      throw new TypeError(`The \"${key}\" argument must be of type number`)\n    }\n    if (!Number.isInteger(value)) {\n      throw new TypeError(`The \"${key}\" argument must be an integer`)\n    }\n    if (value < 1) {\n      throw new RangeError(`The \"${key}\" argument must be >= 1`)\n    }\n  }\n  return value === undefined ? Infinity : value\n}\n\nfunction getItemCount (number) {\n  if (number === 1) {\n    return '1 item'\n  }\n  return `${number} items`\n}\n\nfunction getUniqueReplacerSet (replacerArray) {\n  const replacerSet = new Set()\n  for (const value of replacerArray) {\n    if (typeof value === 'string' || typeof value === 'number') {\n      replacerSet.add(String(value))\n    }\n  }\n  return replacerSet\n}\n\nfunction getStrictOption (options) {\n  if (hasOwnProperty.call(options, 'strict')) {\n    const value = options.strict\n    if (typeof value !== 'boolean') {\n      throw new TypeError('The \"strict\" argument must be of type boolean')\n    }\n    if (value) {\n      return (value) => {\n        let message = `Object can not safely be stringified. Received type ${typeof value}`\n        if (typeof value !== 'function') message += ` (${value.toString()})`\n        throw new Error(message)\n      }\n    }\n  }\n}\n\nfunction configure (options) {\n  options = { ...options }\n  const fail = getStrictOption(options)\n  if (fail) {\n    if (options.bigint === undefined) {\n      options.bigint = false\n    }\n    if (!('circularValue' in options)) {\n      options.circularValue = Error\n    }\n  }\n  const circularValue = getCircularValueOption(options)\n  const bigint = getBooleanOption(options, 'bigint')\n  const deterministic = getBooleanOption(options, 'deterministic')\n  const maximumDepth = getPositiveIntegerOption(options, 'maximumDepth')\n  const maximumBreadth = getPositiveIntegerOption(options, 'maximumBreadth')\n\n  function stringifyFnReplacer (key, parent, stack, replacer, spacer, indentation) {\n    let value = parent[key]\n\n    if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {\n      value = value.toJSON(key)\n    }\n    value = replacer.call(parent, key, value)\n\n    switch (typeof value) {\n      case 'string':\n        return strEscape(value)\n      case 'object': {\n        if (value === null) {\n          return 'null'\n        }\n        if (stack.indexOf(value) !== -1) {\n          return circularValue\n        }\n\n        let res = ''\n        let join = ','\n        const originalIndentation = indentation\n\n        if (Array.isArray(value)) {\n          if (value.length === 0) {\n            return '[]'\n          }\n          if (maximumDepth < stack.length + 1) {\n            return '\"[Array]\"'\n          }\n          stack.push(value)\n          if (spacer !== '') {\n            indentation += spacer\n            res += `\\n${indentation}`\n            join = `,\\n${indentation}`\n          }\n          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)\n          let i = 0\n          for (; i < maximumValuesToStringify - 1; i++) {\n            const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation)\n            res += tmp !== undefined ? tmp : 'null'\n            res += join\n          }\n          const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation)\n          res += tmp !== undefined ? tmp : 'null'\n          if (value.length - 1 > maximumBreadth) {\n            const removedKeys = value.length - maximumBreadth - 1\n            res += `${join}\"... ${getItemCount(removedKeys)} not stringified\"`\n          }\n          if (spacer !== '') {\n            res += `\\n${originalIndentation}`\n          }\n          stack.pop()\n          return `[${res}]`\n        }\n\n        let keys = Object.keys(value)\n        const keyLength = keys.length\n        if (keyLength === 0) {\n          return '{}'\n        }\n        if (maximumDepth < stack.length + 1) {\n          return '\"[Object]\"'\n        }\n        let whitespace = ''\n        let separator = ''\n        if (spacer !== '') {\n          indentation += spacer\n          join = `,\\n${indentation}`\n          whitespace = ' '\n        }\n        const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth)\n        if (deterministic && !isTypedArrayWithEntries(value)) {\n          keys = insertSort(keys)\n        }\n        stack.push(value)\n        for (let i = 0; i < maximumPropertiesToStringify; i++) {\n          const key = keys[i]\n          const tmp = stringifyFnReplacer(key, value, stack, replacer, spacer, indentation)\n          if (tmp !== undefined) {\n            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`\n            separator = join\n          }\n        }\n        if (keyLength > maximumBreadth) {\n          const removedKeys = keyLength - maximumBreadth\n          res += `${separator}\"...\":${whitespace}\"${getItemCount(removedKeys)} not stringified\"`\n          separator = join\n        }\n        if (spacer !== '' && separator.length > 1) {\n          res = `\\n${indentation}${res}\\n${originalIndentation}`\n        }\n        stack.pop()\n        return `{${res}}`\n      }\n      case 'number':\n        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'\n      case 'boolean':\n        return value === true ? 'true' : 'false'\n      case 'undefined':\n        return undefined\n      case 'bigint':\n        if (bigint) {\n          return String(value)\n        }\n        // fallthrough\n      default:\n        return fail ? fail(value) : undefined\n    }\n  }\n\n  function stringifyArrayReplacer (key, value, stack, replacer, spacer, indentation) {\n    if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {\n      value = value.toJSON(key)\n    }\n\n    switch (typeof value) {\n      case 'string':\n        return strEscape(value)\n      case 'object': {\n        if (value === null) {\n          return 'null'\n        }\n        if (stack.indexOf(value) !== -1) {\n          return circularValue\n        }\n\n        const originalIndentation = indentation\n        let res = ''\n        let join = ','\n\n        if (Array.isArray(value)) {\n          if (value.length === 0) {\n            return '[]'\n          }\n          if (maximumDepth < stack.length + 1) {\n            return '\"[Array]\"'\n          }\n          stack.push(value)\n          if (spacer !== '') {\n            indentation += spacer\n            res += `\\n${indentation}`\n            join = `,\\n${indentation}`\n          }\n          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)\n          let i = 0\n          for (; i < maximumValuesToStringify - 1; i++) {\n            const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation)\n            res += tmp !== undefined ? tmp : 'null'\n            res += join\n          }\n          const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation)\n          res += tmp !== undefined ? tmp : 'null'\n          if (value.length - 1 > maximumBreadth) {\n            const removedKeys = value.length - maximumBreadth - 1\n            res += `${join}\"... ${getItemCount(removedKeys)} not stringified\"`\n          }\n          if (spacer !== '') {\n            res += `\\n${originalIndentation}`\n          }\n          stack.pop()\n          return `[${res}]`\n        }\n        stack.push(value)\n        let whitespace = ''\n        if (spacer !== '') {\n          indentation += spacer\n          join = `,\\n${indentation}`\n          whitespace = ' '\n        }\n        let separator = ''\n        for (const key of replacer) {\n          const tmp = stringifyArrayReplacer(key, value[key], stack, replacer, spacer, indentation)\n          if (tmp !== undefined) {\n            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`\n            separator = join\n          }\n        }\n        if (spacer !== '' && separator.length > 1) {\n          res = `\\n${indentation}${res}\\n${originalIndentation}`\n        }\n        stack.pop()\n        return `{${res}}`\n      }\n      case 'number':\n        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'\n      case 'boolean':\n        return value === true ? 'true' : 'false'\n      case 'undefined':\n        return undefined\n      case 'bigint':\n        if (bigint) {\n          return String(value)\n        }\n        // fallthrough\n      default:\n        return fail ? fail(value) : undefined\n    }\n  }\n\n  function stringifyIndent (key, value, stack, spacer, indentation) {\n    switch (typeof value) {\n      case 'string':\n        return strEscape(value)\n      case 'object': {\n        if (value === null) {\n          return 'null'\n        }\n        if (typeof value.toJSON === 'function') {\n          value = value.toJSON(key)\n          // Prevent calling `toJSON` again.\n          if (typeof value !== 'object') {\n            return stringifyIndent(key, value, stack, spacer, indentation)\n          }\n          if (value === null) {\n            return 'null'\n          }\n        }\n        if (stack.indexOf(value) !== -1) {\n          return circularValue\n        }\n        const originalIndentation = indentation\n\n        if (Array.isArray(value)) {\n          if (value.length === 0) {\n            return '[]'\n          }\n          if (maximumDepth < stack.length + 1) {\n            return '\"[Array]\"'\n          }\n          stack.push(value)\n          indentation += spacer\n          let res = `\\n${indentation}`\n          const join = `,\\n${indentation}`\n          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)\n          let i = 0\n          for (; i < maximumValuesToStringify - 1; i++) {\n            const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation)\n            res += tmp !== undefined ? tmp : 'null'\n            res += join\n          }\n          const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation)\n          res += tmp !== undefined ? tmp : 'null'\n          if (value.length - 1 > maximumBreadth) {\n            const removedKeys = value.length - maximumBreadth - 1\n            res += `${join}\"... ${getItemCount(removedKeys)} not stringified\"`\n          }\n          res += `\\n${originalIndentation}`\n          stack.pop()\n          return `[${res}]`\n        }\n\n        let keys = Object.keys(value)\n        const keyLength = keys.length\n        if (keyLength === 0) {\n          return '{}'\n        }\n        if (maximumDepth < stack.length + 1) {\n          return '\"[Object]\"'\n        }\n        indentation += spacer\n        const join = `,\\n${indentation}`\n        let res = ''\n        let separator = ''\n        let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth)\n        if (isTypedArrayWithEntries(value)) {\n          res += stringifyTypedArray(value, join, maximumBreadth)\n          keys = keys.slice(value.length)\n          maximumPropertiesToStringify -= value.length\n          separator = join\n        }\n        if (deterministic) {\n          keys = insertSort(keys)\n        }\n        stack.push(value)\n        for (let i = 0; i < maximumPropertiesToStringify; i++) {\n          const key = keys[i]\n          const tmp = stringifyIndent(key, value[key], stack, spacer, indentation)\n          if (tmp !== undefined) {\n            res += `${separator}${strEscape(key)}: ${tmp}`\n            separator = join\n          }\n        }\n        if (keyLength > maximumBreadth) {\n          const removedKeys = keyLength - maximumBreadth\n          res += `${separator}\"...\": \"${getItemCount(removedKeys)} not stringified\"`\n          separator = join\n        }\n        if (separator !== '') {\n          res = `\\n${indentation}${res}\\n${originalIndentation}`\n        }\n        stack.pop()\n        return `{${res}}`\n      }\n      case 'number':\n        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'\n      case 'boolean':\n        return value === true ? 'true' : 'false'\n      case 'undefined':\n        return undefined\n      case 'bigint':\n        if (bigint) {\n          return String(value)\n        }\n        // fallthrough\n      default:\n        return fail ? fail(value) : undefined\n    }\n  }\n\n  function stringifySimple (key, value, stack) {\n    switch (typeof value) {\n      case 'string':\n        return strEscape(value)\n      case 'object': {\n        if (value === null) {\n          return 'null'\n        }\n        if (typeof value.toJSON === 'function') {\n          value = value.toJSON(key)\n          // Prevent calling `toJSON` again\n          if (typeof value !== 'object') {\n            return stringifySimple(key, value, stack)\n          }\n          if (value === null) {\n            return 'null'\n          }\n        }\n        if (stack.indexOf(value) !== -1) {\n          return circularValue\n        }\n\n        let res = ''\n\n        if (Array.isArray(value)) {\n          if (value.length === 0) {\n            return '[]'\n          }\n          if (maximumDepth < stack.length + 1) {\n            return '\"[Array]\"'\n          }\n          stack.push(value)\n          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)\n          let i = 0\n          for (; i < maximumValuesToStringify - 1; i++) {\n            const tmp = stringifySimple(String(i), value[i], stack)\n            res += tmp !== undefined ? tmp : 'null'\n            res += ','\n          }\n          const tmp = stringifySimple(String(i), value[i], stack)\n          res += tmp !== undefined ? tmp : 'null'\n          if (value.length - 1 > maximumBreadth) {\n            const removedKeys = value.length - maximumBreadth - 1\n            res += `,\"... ${getItemCount(removedKeys)} not stringified\"`\n          }\n          stack.pop()\n          return `[${res}]`\n        }\n\n        let keys = Object.keys(value)\n        const keyLength = keys.length\n        if (keyLength === 0) {\n          return '{}'\n        }\n        if (maximumDepth < stack.length + 1) {\n          return '\"[Object]\"'\n        }\n        let separator = ''\n        let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth)\n        if (isTypedArrayWithEntries(value)) {\n          res += stringifyTypedArray(value, ',', maximumBreadth)\n          keys = keys.slice(value.length)\n          maximumPropertiesToStringify -= value.length\n          separator = ','\n        }\n        if (deterministic) {\n          keys = insertSort(keys)\n        }\n        stack.push(value)\n        for (let i = 0; i < maximumPropertiesToStringify; i++) {\n          const key = keys[i]\n          const tmp = stringifySimple(key, value[key], stack)\n          if (tmp !== undefined) {\n            res += `${separator}${strEscape(key)}:${tmp}`\n            separator = ','\n          }\n        }\n        if (keyLength > maximumBreadth) {\n          const removedKeys = keyLength - maximumBreadth\n          res += `${separator}\"...\":\"${getItemCount(removedKeys)} not stringified\"`\n        }\n        stack.pop()\n        return `{${res}}`\n      }\n      case 'number':\n        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'\n      case 'boolean':\n        return value === true ? 'true' : 'false'\n      case 'undefined':\n        return undefined\n      case 'bigint':\n        if (bigint) {\n          return String(value)\n        }\n        // fallthrough\n      default:\n        return fail ? fail(value) : undefined\n    }\n  }\n\n  function stringify (value, replacer, space) {\n    if (arguments.length > 1) {\n      let spacer = ''\n      if (typeof space === 'number') {\n        spacer = ' '.repeat(Math.min(space, 10))\n      } else if (typeof space === 'string') {\n        spacer = space.slice(0, 10)\n      }\n      if (replacer != null) {\n        if (typeof replacer === 'function') {\n          return stringifyFnReplacer('', { '': value }, [], replacer, spacer, '')\n        }\n        if (Array.isArray(replacer)) {\n          return stringifyArrayReplacer('', value, [], getUniqueReplacerSet(replacer), spacer, '')\n        }\n      }\n      if (spacer.length !== 0) {\n        return stringifyIndent('', value, [], spacer, '')\n      }\n    }\n    return stringifySimple('', value, [])\n  }\n\n  return stringify\n}\n","'use strict'\n\n/**\n * arrays must be sorted and unique\n * @param {*} arrayA\n * @param {*} arrayB\n * @returns {number[]} matching indexes of arrayB\n */\nfunction findMatchingIndexes (arrayA, arrayB) {\n  const found = []\n\n  let lastIndexB = 0\n  for (let indexA = 0; indexA < arrayA.length; indexA++) {\n    for (let indexB = lastIndexB; indexB < arrayB.length; indexB++) {\n      if (arrayA[indexA] === arrayB[indexB]) {\n        found.push(indexB)\n        lastIndexB = indexB + 1\n      }\n    }\n  }\n  return found\n}\n\n/**\n * arrays must be sorted and unique\n * @param {*} arrayA\n * @param {*} arrayB\n * @returns {number[]} values of arrayB not in arrayA\n */\nfunction findNotMatching (arrayA, arrayB) {\n  const found = []\n\n  let lastIndexB = 0\n  for (let indexA = 0; indexA < arrayA.length; indexA++) {\n    for (let indexB = lastIndexB; indexB < arrayB.length; indexB++) {\n      if (arrayA[indexA] !== arrayB[indexB]) {\n        found.push(arrayB[indexB])\n        lastIndexB = indexB + 1\n      }\n    }\n  }\n  return found\n}\n\n/**\n * @param {*} array\n * @param {*} value\n * @return {number} index of value in array, -1 if not found\n */\nfunction bsearchIndex (array, value) {\n  let start = 0\n  let end = array.length - 1\n\n  while (start <= end) {\n    const index = ((start + end) / 2) | 0\n\n    if (array[index] === value) {\n      return index\n    }\n\n    if (array[index] < value) {\n      start = index + 1\n    } else {\n      end = index - 1\n    }\n  }\n\n  return -1\n}\n\nfunction randomNumber (max) {\n  return (max * Math.random()) | 0\n}\n\nfunction randomInRange (min, max) {\n  min = Math.floor(min)\n  max = Math.floor(max)\n  return min + randomNumber(1 + max - min)\n}\n\nfunction randomSubset (array, size) {\n  if (array.length < 1 || size < 1) return []\n\n  const limit = Math.min(array.length, size)\n  const n = randomInRange(1, limit)\n  const indexes = new Set()\n  for (let i = 0; i < n; i++) {\n    indexes.add(randomNumber(array.length))\n  }\n  const result = []\n  for (const i of indexes) {\n    result.push(array[i])\n  }\n\n  return result\n}\n\n/**\n * @param {!string} value substring to search in content, supporting wildcard\n * @param {!string} content string to search in\n * @return {boolean} true if value is in content\n * @example wildcardMatch(\"1*5\", \"12345\") > true\n * @example wildcardMatch(\"1*6\", \"12345\") > false\n */\nfunction wildcardMatch (value, content) {\n  if (value === '*') return true\n  if (value.length === content.length && value === content) return true\n\n  let i = 0; let j = 0\n  while (i < value.length && j < content.length) {\n    if (value[i] === content[j]) {\n      i++\n      j++\n      continue\n    }\n    if (value[i] === '*') {\n      if (value[i + 1] === content[j]) {\n        i++\n        continue\n      }\n      j++\n      continue\n    }\n    return false\n  }\n\n  return i >= value.length - 1\n}\n\n// `abstract-logging` dependency has been removed because there is a bug on Rollup\n// https://github.com/jsumners/abstract-logging/issues/6\nfunction abstractLogging () {\n  const noop = () => {}\n  return {\n    fatal: noop,\n    error: noop,\n    warn: noop,\n    info: noop,\n    debug: noop,\n    trace: noop\n  }\n}\n\nconst isServerSide = typeof window === 'undefined'\n\nmodule.exports = {\n  findNotMatching,\n  findMatchingIndexes,\n  bsearchIndex,\n  wildcardMatch,\n  randomSubset,\n  abstractLogging,\n  isServerSide\n}\n","'use strict'\n\nclass StorageInterface {\n  constructor (options) {\n    this.options = options\n  }\n\n  /**\n   * @param {string} key\n   * @returns {undefined|*} undefined if key not found\n   */\n  async get (key) { throw new Error('storage get method not implemented') }\n  /**\n   * @param {string} key\n   * @param {*} value\n   * @param {number} ttl - ttl in seconds; zero means key will not be stored\n   * @param {?string[]} references\n   */\n  async set (key, value, ttl, references) { throw new Error('storage set method not implemented') }\n  /**\n   * @param {string} key\n   */\n  async remove (key) { throw new Error('storage remove method not implemented') }\n  /**\n   * @param {string[]} references\n   */\n  async invalidate (references) { throw new Error('storage invalidate method not implemented') }\n  /**\n   * @param {string} name\n   */\n  async clear (name) { throw new Error('storage clear method not implemented') }\n  async refresh () { throw new Error('storage refresh method not implemented') }\n}\n\nmodule.exports = StorageInterface\n","/**\n * Obliterator Iterator Class\n * ===========================\n *\n * Simple class representing the library's iterators.\n */\n\n/**\n * Iterator class.\n *\n * @constructor\n * @param {function} next - Next function.\n */\nfunction Iterator(next) {\n  if (typeof next !== 'function')\n    throw new Error('obliterator/iterator: expecting a function!');\n\n  this.next = next;\n}\n\n/**\n * If symbols are supported, we add `next` to `Symbol.iterator`.\n */\nif (typeof Symbol !== 'undefined')\n  Iterator.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n\n/**\n * Returning an iterator of the given values.\n *\n * @param  {any...} values - Values.\n * @return {Iterator}\n */\nIterator.of = function () {\n  var args = arguments,\n    l = args.length,\n    i = 0;\n\n  return new Iterator(function () {\n    if (i >= l) return {done: true};\n\n    return {done: false, value: args[i++]};\n  });\n};\n\n/**\n * Returning an empty iterator.\n *\n * @return {Iterator}\n */\nIterator.empty = function () {\n  var iterator = new Iterator(function () {\n    return {done: true};\n  });\n\n  return iterator;\n};\n\n/**\n * Returning an iterator over the given indexed sequence.\n *\n * @param  {string|Array} sequence - Target sequence.\n * @return {Iterator}\n */\nIterator.fromSequence = function (sequence) {\n  var i = 0,\n    l = sequence.length;\n\n  return new Iterator(function () {\n    if (i >= l) return {done: true};\n\n    return {done: false, value: sequence[i++]};\n  });\n};\n\n/**\n * Returning whether the given value is an iterator.\n *\n * @param  {any} value - Value.\n * @return {boolean}\n */\nIterator.is = function (value) {\n  if (value instanceof Iterator) return true;\n\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    typeof value.next === 'function'\n  );\n};\n\n/**\n * Exporting.\n */\nmodule.exports = Iterator;\n","exports.ARRAY_BUFFER_SUPPORT = typeof ArrayBuffer !== 'undefined';\nexports.SYMBOL_SUPPORT = typeof Symbol !== 'undefined';\n","/**\n * Obliterator ForEach Function\n * =============================\n *\n * Helper function used to easily iterate over mixed values.\n */\nvar support = require('./support.js');\n\nvar ARRAY_BUFFER_SUPPORT = support.ARRAY_BUFFER_SUPPORT;\nvar SYMBOL_SUPPORT = support.SYMBOL_SUPPORT;\n\n/**\n * Function able to iterate over almost any iterable JS value.\n *\n * @param  {any}      iterable - Iterable value.\n * @param  {function} callback - Callback function.\n */\nmodule.exports = function forEach(iterable, callback) {\n  var iterator, k, i, l, s;\n\n  if (!iterable) throw new Error('obliterator/forEach: invalid iterable.');\n\n  if (typeof callback !== 'function')\n    throw new Error('obliterator/forEach: expecting a callback.');\n\n  // The target is an array or a string or function arguments\n  if (\n    Array.isArray(iterable) ||\n    (ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(iterable)) ||\n    typeof iterable === 'string' ||\n    iterable.toString() === '[object Arguments]'\n  ) {\n    for (i = 0, l = iterable.length; i < l; i++) callback(iterable[i], i);\n    return;\n  }\n\n  // The target has a #.forEach method\n  if (typeof iterable.forEach === 'function') {\n    iterable.forEach(callback);\n    return;\n  }\n\n  // The target is iterable\n  if (\n    SYMBOL_SUPPORT &&\n    Symbol.iterator in iterable &&\n    typeof iterable.next !== 'function'\n  ) {\n    iterable = iterable[Symbol.iterator]();\n  }\n\n  // The target is an iterator\n  if (typeof iterable.next === 'function') {\n    iterator = iterable;\n    i = 0;\n\n    while (((s = iterator.next()), s.done !== true)) {\n      callback(s.value, i);\n      i++;\n    }\n\n    return;\n  }\n\n  // The target is a plain object\n  for (k in iterable) {\n    if (iterable.hasOwnProperty(k)) {\n      callback(iterable[k], k);\n    }\n  }\n\n  return;\n};\n","/**\n * Mnemonist Typed Array Helpers\n * ==============================\n *\n * Miscellaneous helpers related to typed arrays.\n */\n\n/**\n * When using an unsigned integer array to store pointers, one might want to\n * choose the optimal word size in regards to the actual numbers of pointers\n * to store.\n *\n * This helpers does just that.\n *\n * @param  {number} size - Expected size of the array to map.\n * @return {TypedArray}\n */\nvar MAX_8BIT_INTEGER = Math.pow(2, 8) - 1,\n    MAX_16BIT_INTEGER = Math.pow(2, 16) - 1,\n    MAX_32BIT_INTEGER = Math.pow(2, 32) - 1;\n\nvar MAX_SIGNED_8BIT_INTEGER = Math.pow(2, 7) - 1,\n    MAX_SIGNED_16BIT_INTEGER = Math.pow(2, 15) - 1,\n    MAX_SIGNED_32BIT_INTEGER = Math.pow(2, 31) - 1;\n\nexports.getPointerArray = function(size) {\n  var maxIndex = size - 1;\n\n  if (maxIndex <= MAX_8BIT_INTEGER)\n    return Uint8Array;\n\n  if (maxIndex <= MAX_16BIT_INTEGER)\n    return Uint16Array;\n\n  if (maxIndex <= MAX_32BIT_INTEGER)\n    return Uint32Array;\n\n  throw new Error('mnemonist: Pointer Array of size > 4294967295 is not supported.');\n};\n\nexports.getSignedPointerArray = function(size) {\n  var maxIndex = size - 1;\n\n  if (maxIndex <= MAX_SIGNED_8BIT_INTEGER)\n    return Int8Array;\n\n  if (maxIndex <= MAX_SIGNED_16BIT_INTEGER)\n    return Int16Array;\n\n  if (maxIndex <= MAX_SIGNED_32BIT_INTEGER)\n    return Int32Array;\n\n  return Float64Array;\n};\n\n/**\n * Function returning the minimal type able to represent the given number.\n *\n * @param  {number} value - Value to test.\n * @return {TypedArrayClass}\n */\nexports.getNumberType = function(value) {\n\n  // <= 32 bits itnteger?\n  if (value === (value | 0)) {\n\n    // Negative\n    if (Math.sign(value) === -1) {\n      if (value <= 127 && value >= -128)\n        return Int8Array;\n\n      if (value <= 32767 && value >= -32768)\n        return Int16Array;\n\n      return Int32Array;\n    }\n    else {\n\n      if (value <= 255)\n        return Uint8Array;\n\n      if (value <= 65535)\n        return Uint16Array;\n\n      return Uint32Array;\n    }\n  }\n\n  // 53 bits integer & floats\n  // NOTE: it's kinda hard to tell whether we could use 32bits or not...\n  return Float64Array;\n};\n\n/**\n * Function returning the minimal type able to represent the given array\n * of JavaScript numbers.\n *\n * @param  {array}    array  - Array to represent.\n * @param  {function} getter - Optional getter.\n * @return {TypedArrayClass}\n */\nvar TYPE_PRIORITY = {\n  Uint8Array: 1,\n  Int8Array: 2,\n  Uint16Array: 3,\n  Int16Array: 4,\n  Uint32Array: 5,\n  Int32Array: 6,\n  Float32Array: 7,\n  Float64Array: 8\n};\n\n// TODO: make this a one-shot for one value\nexports.getMinimalRepresentation = function(array, getter) {\n  var maxType = null,\n      maxPriority = 0,\n      p,\n      t,\n      v,\n      i,\n      l;\n\n  for (i = 0, l = array.length; i < l; i++) {\n    v = getter ? getter(array[i]) : array[i];\n    t = exports.getNumberType(v);\n    p = TYPE_PRIORITY[t.name];\n\n    if (p > maxPriority) {\n      maxPriority = p;\n      maxType = t;\n    }\n  }\n\n  return maxType;\n};\n\n/**\n * Function returning whether the given value is a typed array.\n *\n * @param  {any} value - Value to test.\n * @return {boolean}\n */\nexports.isTypedArray = function(value) {\n  return typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView(value);\n};\n\n/**\n * Function used to concat byte arrays.\n *\n * @param  {...ByteArray}\n * @return {ByteArray}\n */\nexports.concat = function() {\n  var length = 0,\n      i,\n      o,\n      l;\n\n  for (i = 0, l = arguments.length; i < l; i++)\n    length += arguments[i].length;\n\n  var array = new (arguments[0].constructor)(length);\n\n  for (i = 0, o = 0; i < l; i++) {\n    array.set(arguments[i], o);\n    o += arguments[i].length;\n  }\n\n  return array;\n};\n\n/**\n * Function used to initialize a byte array of indices.\n *\n * @param  {number}    length - Length of target.\n * @return {ByteArray}\n */\nexports.indices = function(length) {\n  var PointerArray = exports.getPointerArray(length);\n\n  var array = new PointerArray(length);\n\n  for (var i = 0; i < length; i++)\n    array[i] = i;\n\n  return array;\n};\n","/**\n * Mnemonist Iterable Function\n * ============================\n *\n * Harmonized iteration helpers over mixed iterable targets.\n */\nvar forEach = require('obliterator/foreach');\n\nvar typed = require('./typed-arrays.js');\n\n/**\n * Function used to determine whether the given object supports array-like\n * random access.\n *\n * @param  {any} target - Target object.\n * @return {boolean}\n */\nfunction isArrayLike(target) {\n  return Array.isArray(target) || typed.isTypedArray(target);\n}\n\n/**\n * Function used to guess the length of the structure over which we are going\n * to iterate.\n *\n * @param  {any} target - Target object.\n * @return {number|undefined}\n */\nfunction guessLength(target) {\n  if (typeof target.length === 'number')\n    return target.length;\n\n  if (typeof target.size === 'number')\n    return target.size;\n\n  return;\n}\n\n/**\n * Function used to convert an iterable to an array.\n *\n * @param  {any}   target - Iteration target.\n * @return {array}\n */\nfunction toArray(target) {\n  var l = guessLength(target);\n\n  var array = typeof l === 'number' ? new Array(l) : [];\n\n  var i = 0;\n\n  // TODO: we could optimize when given target is array like\n  forEach(target, function(value) {\n    array[i++] = value;\n  });\n\n  return array;\n}\n\n/**\n * Same as above but returns a supplementary indices array.\n *\n * @param  {any}   target - Iteration target.\n * @return {array}\n */\nfunction toArrayWithIndices(target) {\n  var l = guessLength(target);\n\n  var IndexArray = typeof l === 'number' ?\n    typed.getPointerArray(l) :\n    Array;\n\n  var array = typeof l === 'number' ? new Array(l) : [];\n  var indices = typeof l === 'number' ? new IndexArray(l) : [];\n\n  var i = 0;\n\n  // TODO: we could optimize when given target is array like\n  forEach(target, function(value) {\n    array[i] = value;\n    indices[i] = i++;\n  });\n\n  return [array, indices];\n}\n\n/**\n * Exporting.\n */\nexports.isArrayLike = isArrayLike;\nexports.guessLength = guessLength;\nexports.toArray = toArray;\nexports.toArrayWithIndices = toArrayWithIndices;\n","/**\n * Mnemonist LRUCache\n * ===================\n *\n * JavaScript implementation of the LRU Cache data structure. To save up\n * memory and allocations this implementation represents its underlying\n * doubly-linked list as static arrays and pointers. Thus, memory is allocated\n * only once at instantiation and JS objects are never created to serve as\n * pointers. This also means this implementation does not trigger too many\n * garbage collections.\n *\n * Note that to save up memory, a LRU Cache can be implemented using a singly\n * linked list by storing predecessors' pointers as hashmap values.\n * However, this means more hashmap lookups and would probably slow the whole\n * thing down. What's more, pointers are not the things taking most space in\n * memory.\n */\nvar Iterator = require('obliterator/iterator'),\n    forEach = require('obliterator/foreach'),\n    typed = require('./utils/typed-arrays.js'),\n    iterables = require('./utils/iterables.js');\n\n/**\n * LRUCache.\n *\n * @constructor\n * @param {function} Keys     - Array class for storing keys.\n * @param {function} Values   - Array class for storing values.\n * @param {number}   capacity - Desired capacity.\n */\nfunction LRUCache(Keys, Values, capacity) {\n  if (arguments.length < 2) {\n    capacity = Keys;\n    Keys = null;\n    Values = null;\n  }\n\n  this.capacity = capacity;\n\n  if (typeof this.capacity !== 'number' || this.capacity <= 0)\n    throw new Error('mnemonist/lru-cache: capacity should be positive number.');\n  else if (!isFinite(this.capacity) || Math.floor(this.capacity) !== this.capacity)\n    throw new Error('mnemonist/lru-cache: capacity should be a finite positive integer.');\n\n  var PointerArray = typed.getPointerArray(capacity);\n\n  this.forward = new PointerArray(capacity);\n  this.backward = new PointerArray(capacity);\n  this.K = typeof Keys === 'function' ? new Keys(capacity) : new Array(capacity);\n  this.V = typeof Values === 'function' ? new Values(capacity) : new Array(capacity);\n\n  // Properties\n  this.size = 0;\n  this.head = 0;\n  this.tail = 0;\n  this.items = {};\n}\n\n/**\n * Method used to clear the structure.\n *\n * @return {undefined}\n */\nLRUCache.prototype.clear = function() {\n  this.size = 0;\n  this.head = 0;\n  this.tail = 0;\n  this.items = {};\n};\n\n/**\n * Method used to splay a value on top.\n *\n * @param  {number}   pointer - Pointer of the value to splay on top.\n * @return {LRUCache}\n */\nLRUCache.prototype.splayOnTop = function(pointer) {\n  var oldHead = this.head;\n\n  if (this.head === pointer)\n    return this;\n\n  var previous = this.backward[pointer],\n      next = this.forward[pointer];\n\n  if (this.tail === pointer) {\n    this.tail = previous;\n  }\n  else {\n    this.backward[next] = previous;\n  }\n\n  this.forward[previous] = next;\n\n  this.backward[oldHead] = pointer;\n  this.head = pointer;\n  this.forward[pointer] = oldHead;\n\n  return this;\n};\n\n/**\n * Method used to set the value for the given key in the cache.\n *\n * @param  {any} key   - Key.\n * @param  {any} value - Value.\n * @return {undefined}\n */\nLRUCache.prototype.set = function(key, value) {\n\n  var pointer = this.items[key];\n\n  // The key already exists, we just need to update the value and splay on top\n  if (typeof pointer !== 'undefined') {\n    this.splayOnTop(pointer);\n    this.V[pointer] = value;\n\n    return;\n  }\n\n  // The cache is not yet full\n  if (this.size < this.capacity) {\n    pointer = this.size++;\n  }\n\n  // Cache is full, we need to drop the last value\n  else {\n    pointer = this.tail;\n    this.tail = this.backward[pointer];\n    delete this.items[this.K[pointer]];\n  }\n\n  // Storing key & value\n  this.items[key] = pointer;\n  this.K[pointer] = key;\n  this.V[pointer] = value;\n\n  // Moving the item at the front of the list\n  this.forward[pointer] = this.head;\n  this.backward[this.head] = pointer;\n  this.head = pointer;\n};\n\n/**\n * Method used to set the value for the given key in the cache\n *\n * @param  {any} key   - Key.\n * @param  {any} value - Value.\n * @return {{evicted: boolean, key: any, value: any}} An object containing the\n * key and value of an item that was overwritten or evicted in the set\n * operation, as well as a boolean indicating whether it was evicted due to\n * limited capacity. Return value is null if nothing was evicted or overwritten\n * during the set operation.\n */\nLRUCache.prototype.setpop = function(key, value) {\n  var oldValue = null;\n  var oldKey = null;\n\n  var pointer = this.items[key];\n\n  // The key already exists, we just need to update the value and splay on top\n  if (typeof pointer !== 'undefined') {\n    this.splayOnTop(pointer);\n    oldValue = this.V[pointer];\n    this.V[pointer] = value;\n    return {evicted: false, key: key, value: oldValue};\n  }\n\n  // The cache is not yet full\n  if (this.size < this.capacity) {\n    pointer = this.size++;\n  }\n\n  // Cache is full, we need to drop the last value\n  else {\n    pointer = this.tail;\n    this.tail = this.backward[pointer];\n    oldValue = this.V[pointer];\n    oldKey = this.K[pointer];\n    delete this.items[oldKey];\n  }\n\n  // Storing key & value\n  this.items[key] = pointer;\n  this.K[pointer] = key;\n  this.V[pointer] = value;\n\n  // Moving the item at the front of the list\n  this.forward[pointer] = this.head;\n  this.backward[this.head] = pointer;\n  this.head = pointer;\n\n  // Return object if eviction took place, otherwise return null\n  if (oldKey) {\n    return {evicted: true, key: oldKey, value: oldValue};\n  }\n  else {\n    return null;\n  }\n};\n\n/**\n * Method used to check whether the key exists in the cache.\n *\n * @param  {any} key   - Key.\n * @return {boolean}\n */\nLRUCache.prototype.has = function(key) {\n  return key in this.items;\n};\n\n/**\n * Method used to get the value attached to the given key. Will move the\n * related key to the front of the underlying linked list.\n *\n * @param  {any} key   - Key.\n * @return {any}\n */\nLRUCache.prototype.get = function(key) {\n  var pointer = this.items[key];\n\n  if (typeof pointer === 'undefined')\n    return;\n\n  this.splayOnTop(pointer);\n\n  return this.V[pointer];\n};\n\n/**\n * Method used to get the value attached to the given key. Does not modify\n * the ordering of the underlying linked list.\n *\n * @param  {any} key   - Key.\n * @return {any}\n */\nLRUCache.prototype.peek = function(key) {\n  var pointer = this.items[key];\n\n  if (typeof pointer === 'undefined')\n    return;\n\n  return this.V[pointer];\n};\n\n/**\n * Method used to iterate over the cache's entries using a callback.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\nLRUCache.prototype.forEach = function(callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n\n  var i = 0,\n      l = this.size;\n\n  var pointer = this.head,\n      keys = this.K,\n      values = this.V,\n      forward = this.forward;\n\n  while (i < l) {\n\n    callback.call(scope, values[pointer], keys[pointer], this);\n    pointer = forward[pointer];\n\n    i++;\n  }\n};\n\n/**\n * Method used to create an iterator over the cache's keys from most\n * recently used to least recently used.\n *\n * @return {Iterator}\n */\nLRUCache.prototype.keys = function() {\n  var i = 0,\n      l = this.size;\n\n  var pointer = this.head,\n      keys = this.K,\n      forward = this.forward;\n\n  return new Iterator(function() {\n    if (i >= l)\n      return {done: true};\n\n    var key = keys[pointer];\n\n    i++;\n\n    if (i < l)\n      pointer = forward[pointer];\n\n    return {\n      done: false,\n      value: key\n    };\n  });\n};\n\n/**\n * Method used to create an iterator over the cache's values from most\n * recently used to least recently used.\n *\n * @return {Iterator}\n */\nLRUCache.prototype.values = function() {\n  var i = 0,\n      l = this.size;\n\n  var pointer = this.head,\n      values = this.V,\n      forward = this.forward;\n\n  return new Iterator(function() {\n    if (i >= l)\n      return {done: true};\n\n    var value = values[pointer];\n\n    i++;\n\n    if (i < l)\n      pointer = forward[pointer];\n\n    return {\n      done: false,\n      value: value\n    };\n  });\n};\n\n/**\n * Method used to create an iterator over the cache's entries from most\n * recently used to least recently used.\n *\n * @return {Iterator}\n */\nLRUCache.prototype.entries = function() {\n  var i = 0,\n      l = this.size;\n\n  var pointer = this.head,\n      keys = this.K,\n      values = this.V,\n      forward = this.forward;\n\n  return new Iterator(function() {\n    if (i >= l)\n      return {done: true};\n\n    var key = keys[pointer],\n        value = values[pointer];\n\n    i++;\n\n    if (i < l)\n      pointer = forward[pointer];\n\n    return {\n      done: false,\n      value: [key, value]\n    };\n  });\n};\n\n/**\n * Attaching the #.entries method to Symbol.iterator if possible.\n */\nif (typeof Symbol !== 'undefined')\n  LRUCache.prototype[Symbol.iterator] = LRUCache.prototype.entries;\n\n/**\n * Convenience known methods.\n */\nLRUCache.prototype.inspect = function() {\n  var proxy = new Map();\n\n  var iterator = this.entries(),\n      step;\n\n  while ((step = iterator.next(), !step.done))\n    proxy.set(step.value[0], step.value[1]);\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(proxy, 'constructor', {\n    value: LRUCache,\n    enumerable: false\n  });\n\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined')\n  LRUCache.prototype[Symbol.for('nodejs.util.inspect.custom')] = LRUCache.prototype.inspect;\n\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a structure.\n *\n * @param  {Iterable} iterable - Target iterable.\n * @param  {function} Keys     - Array class for storing keys.\n * @param  {function} Values   - Array class for storing values.\n * @param  {number}   capacity - Cache's capacity.\n * @return {LRUCache}\n */\nLRUCache.from = function(iterable, Keys, Values, capacity) {\n  if (arguments.length < 2) {\n    capacity = iterables.guessLength(iterable);\n\n    if (typeof capacity !== 'number')\n      throw new Error('mnemonist/lru-cache.from: could not guess iterable length. Please provide desired capacity as last argument.');\n  }\n  else if (arguments.length === 2) {\n    capacity = Keys;\n    Keys = null;\n    Values = null;\n  }\n\n  var cache = new LRUCache(Keys, Values, capacity);\n\n  forEach(iterable, function(value, key) {\n    cache.set(key, value);\n  });\n\n  return cache;\n};\n\n/**\n * Exporting.\n */\nmodule.exports = LRUCache;\n","'use strict'\n\nconst LRUCache = require('mnemonist/lru-cache')\nconst { abstractLogging } = require('../util')\nconst StorageInterface = require('./interface')\nconst { findMatchingIndexes, findNotMatching, bsearchIndex, wildcardMatch } = require('../util')\n\n/* c8 ignore next */\nconst setImmediate = typeof globalThis.setImmediate !== 'undefined' ? globalThis.setImmediate : (fn, ...args) => setTimeout(fn, 0, ...args)\n\nconst DEFAULT_CACHE_SIZE = 1024\n\n/**\n * @typedef StorageMemoryOptions\n * @property {?number} [size=1024]\n * @property {?Logger} [log]\n * @property {?boolean} [invalidation=false]\n */\n\nclass StorageMemory extends StorageInterface {\n  /**\n   * in-memory storage\n   * @param {StorageMemoryOptions} options\n   */\n  constructor (options = {}) {\n    if (options.size && (typeof options.size !== 'number' || options.size < 1)) {\n      throw new Error('size must be a positive integer greater than 0')\n    }\n\n    super(options)\n    this.size = options.size || DEFAULT_CACHE_SIZE\n    this.log = options.log || abstractLogging()\n    this.invalidation = options.invalidation || false\n\n    this.init()\n  }\n\n  init () {\n    this.store = new LRUCache(this.size)\n\n    if (!this.invalidation) {\n      return\n    }\n    // key -> references, keys are strings, references are sorted array strings\n    this.keysReferences = new Map()\n    // same as above, but inverted\n    this.referencesKeys = new Map()\n  }\n\n  /**\n   * retrieve the value by key\n   * @param {string} key\n   * @returns {undefined|*} undefined if key not found or expired\n   */\n  get (key) {\n    this.log.debug({ msg: 'acd/storage/memory.get', key })\n\n    const entry = this.store.get(key)\n    if (entry) {\n      this.log.debug({ msg: 'acd/storage/memory.get, entry', entry, now: now() })\n      if (entry.start + entry.ttl > now()) {\n        this.log.debug({ msg: 'acd/storage/memory.get, key is NOT expired', key, entry })\n        return entry.value\n      }\n      this.log.debug({ msg: 'acd/storage/memory.get, key is EXPIRED', key, entry })\n\n      // no need to wait for key to be removed\n\n      setImmediate(() => this.remove(key))\n    }\n  }\n\n  /**\n   * retrieve the remaining TTL value by key\n   * @param {string} key\n   * @returns {undefined|*} undefined if key not found or expired\n   */\n  getTTL (key) {\n    this.log.debug({ msg: 'acd/storage/memory.getTTL', key })\n\n    const entry = this.store.peek(key)\n    let ttl = 0\n    if (entry) {\n      ttl = entry.start + entry.ttl - now()\n      if (ttl < 0) {\n        ttl = 0\n      }\n    }\n\n    return ttl\n  }\n\n  /**\n   * set value by key\n   * @param {string} key\n   * @param {*} value\n   * @param {?number} [ttl=0] - ttl in seconds; zero means key will not be stored\n   * @param {?string[]} references\n   */\n  set (key, value, ttl, references) {\n    this.log.debug({ msg: 'acd/storage/memory.set', key, value, ttl, references })\n\n    ttl = Number(ttl)\n    if (!ttl || ttl < 0) {\n      return\n    }\n    const existingKey = this.store.has(key)\n    const removed = this.store.setpop(key, { value, ttl, start: now() })\n    this.log.debug({ msg: 'acd/storage/memory.set, evicted', removed })\n    if (removed && removed.evicted) {\n      this.log.debug({ msg: 'acd/storage/memory.set, remove evicted key', key: removed.key })\n      this._removeReferences([removed.key])\n    }\n\n    if (!references || references.length < 1) {\n      return\n    }\n\n    if (!this.invalidation) {\n      this.log.warn({ msg: 'acd/storage/memory.set, invalidation is disabled, references are useless' })\n      return\n    }\n\n    // references must be unique\n    references = [...new Set(references)]\n\n    // clear old references\n    let currentReferences\n    if (existingKey) {\n      currentReferences = this.keysReferences.get(key)\n      this.log.debug({ msg: 'acd/storage/memory.set, current keys-references', key, references: currentReferences })\n      if (currentReferences) {\n        currentReferences.sort()\n        references.sort()\n        const referencesToRemove = findNotMatching(references, currentReferences)\n\n        // remove key in old references\n        for (const reference of referencesToRemove) {\n          const keys = this.referencesKeys.get(reference)\n          /* c8 ignore next */\n          if (!keys) { continue }\n          const index = bsearchIndex(keys, key)\n          /* c8 ignore next */\n          if (index < 0) { continue }\n          keys.splice(index, 1)\n\n          if (keys.length < 1) {\n            this.referencesKeys.delete(reference)\n            continue\n          }\n          this.referencesKeys.set(reference, keys)\n        }\n      }\n    }\n\n    // TODO we can probably get referencesToAdd and referencesToRemove in a single loop\n    const referencesToAdd = currentReferences ? findNotMatching(currentReferences, references) : references\n\n    for (let i = 0; i < referencesToAdd.length; i++) {\n      const reference = referencesToAdd[i]\n      let keys = this.referencesKeys.get(reference)\n      if (keys) {\n        this.log.debug({ msg: 'acd/storage/memory.set, add reference-key', key, reference })\n        keys.push(key)\n      } else {\n        keys = [key]\n      }\n      this.log.debug({ msg: 'acd/storage/memory.set, set reference-keys', keys, reference })\n      this.referencesKeys.set(reference, keys)\n    }\n\n    this.keysReferences.set(key, references)\n  }\n\n  /**\n   * remove an entry by key\n   * @param {string} key\n   * @returns {boolean} indicates if key was removed\n   */\n  remove (key) {\n    this.log.debug({ msg: 'acd/storage/memory.remove', key })\n\n    const removed = this._removeKey(key)\n    this._removeReferences([key])\n    return removed\n  }\n\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  _removeKey (key) {\n    this.log.debug({ msg: 'acd/storage/memory._removeKey', key })\n    if (!this.store.has(key)) {\n      return false\n    }\n    this.store.set(key, undefined)\n    return true\n  }\n\n  /**\n   * @param {string[]} keys\n   */\n  _removeReferences (keys) {\n    if (!this.invalidation) {\n      return\n    }\n    this.log.debug({ msg: 'acd/storage/memory._removeReferences', keys })\n\n    const referencesToRemove = new Set()\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i]\n\n      const references = this.keysReferences.get(key)\n      if (!references) {\n        continue\n      }\n\n      for (let j = 0; j < references.length; j++) {\n        referencesToRemove.add(references[j])\n      }\n\n      this.log.debug({ msg: 'acd/storage/memory._removeReferences, delete key-references', key })\n      this.keysReferences.delete(key)\n    }\n\n    this._removeReferencesKeys([...referencesToRemove], keys)\n  }\n\n  /**\n   * @param {!string[]} references\n   * @param {string[]} keys\n   */\n  _removeReferencesKeys (references, keys) {\n    keys.sort()\n    this.log.debug({ msg: 'acd/storage/memory._removeReferencesKeys', references, keys })\n    for (let i = 0; i < references.length; i++) {\n      const reference = references[i]\n      // working on the original stored array\n      const referencesKeys = this.referencesKeys.get(reference)\n      this.log.debug({ msg: 'acd/storage/memory._removeReferencesKeys, get reference-key', reference, keys, referencesKeys })\n      /* c8 ignore next */\n      if (!referencesKeys) continue\n\n      const referencesToRemove = findMatchingIndexes(keys, referencesKeys)\n      // cannot happen that referencesToRemove is empty\n      // because this function is triggered only by _removeReferences\n      // and \"keys\" are from tis.keyReferences\n      // if (referencesToRemove.length < 1) { continue }\n\n      this.log.debug({ msg: 'acd/storage/memory._removeReferencesKeys, removing', reference, referencesToRemove, referencesKeys })\n\n      if (referencesToRemove.length === referencesKeys.length) {\n        this.log.debug({ msg: 'acd/storage/memory._removeReferencesKeys, delete', reference })\n        this.referencesKeys.delete(reference)\n        continue\n      }\n\n      for (let j = referencesToRemove.length - 1; j >= 0; j--) {\n        this.log.debug({ msg: 'acd/storage/memory._removeReferencesKeys, remove', reference, referencesKeys, at: referencesToRemove[j] })\n        referencesKeys.splice(referencesToRemove[j], 1)\n      }\n    }\n  }\n\n  /**\n   * @param {string|string[]} references\n   * @returns {string[]} removed keys\n   */\n  invalidate (references) {\n    if (!this.invalidation) {\n      this.log.warn({ msg: 'acd/storage/memory.invalidate, exit due invalidation is disabled' })\n      return []\n    }\n\n    this.log.debug({ msg: 'acd/storage/memory.invalidate', references })\n\n    if (Array.isArray(references)) {\n      return this._invalidateReferences(references)\n    }\n    return this._invalidateReference(references)\n  }\n\n  /**\n   * @param {string[]} references\n   * @returns {string[]} removed keys\n   */\n  _invalidateReferences (references) {\n    const removed = []\n    for (let i = 0; i < references.length; i++) {\n      const reference = references[i]\n      const keys = this.referencesKeys.get(reference)\n      this.log.debug({ msg: 'acd/storage/memory._invalidateReferences, remove keys on reference', reference, keys })\n      if (!keys) {\n        continue\n      }\n\n      for (let j = 0; j < keys.length; j++) {\n        const key = keys[j]\n        this.log.debug({ msg: 'acd/storage/memory._invalidateReferences, remove key on reference', reference, key })\n        if (this._removeKey(key)) {\n          removed.push(key)\n        }\n      }\n\n      this.log.debug({ msg: 'acd/storage/memory._invalidateReferences, remove references of', reference, keys })\n      this._removeReferences([...keys])\n    }\n\n    return removed\n  }\n\n  /**\n   * @param {string} reference\n   * @returns {string[]} removed keys\n   */\n  _invalidateReference (reference) {\n    if (reference.includes('*')) {\n      const references = []\n      for (const key of this.referencesKeys.keys()) {\n        if (wildcardMatch(reference, key)) {\n          references.push(key)\n        }\n      }\n      return this._invalidateReferences(references)\n    }\n\n    const keys = this.referencesKeys.get(reference)\n    const removed = []\n    this.log.debug({ msg: 'acd/storage/memory._invalidateReference, remove keys on reference', reference, keys })\n\n    if (!keys) {\n      return removed\n    }\n\n    for (let j = 0; j < keys.length; j++) {\n      const key = keys[j]\n      this.log.debug({ msg: 'acd/storage/memory._invalidateReference, remove key on reference', reference, key })\n      if (this._removeKey(key)) {\n        removed.push(key)\n      }\n    }\n\n    this.log.debug({ msg: 'acd/storage/memory._invalidateReference, remove references of', reference, keys })\n    this._removeReferences([...keys])\n\n    return removed\n  }\n\n  /**\n   * remove all entries if name is not provided\n   * remove entries where key starts with name if provided\n   * @param {?string} name\n   * @return {string[]} removed keys\n   */\n  clear (name) {\n    this.log.debug({ msg: 'acd/storage/memory.clear', name })\n\n    if (!name) {\n      this.store.clear()\n      if (!this.invalidation) { return }\n      this.referencesKeys.clear()\n      this.keysReferences.clear()\n      return\n    }\n\n    const keys = []\n    this.store.forEach((value, key) => {\n      this.log.debug({ msg: 'acd/storage/memory.clear, iterate key', key })\n      if (key.indexOf(name) === 0) {\n        this.log.debug({ msg: 'acd/storage/memory.clear, remove key', key })\n        // can't remove here or the loop won't work\n        keys.push(key)\n      }\n    })\n\n    const removed = []\n    // remove all keys at first, then references\n    for (let i = 0; i < keys.length; i++) {\n      if (this._removeKey(keys[i])) {\n        removed.push(keys[i])\n      }\n    }\n\n    this._removeReferences(removed)\n\n    return removed\n  }\n\n  refresh () {\n    this.log.debug({ msg: 'acd/storage/memory.refresh' })\n\n    this.init()\n  }\n}\n\nlet _timer\n\nfunction now () {\n  if (_timer !== undefined) {\n    return _timer\n  }\n  _timer = Math.floor(Date.now() / 1000)\n  const timeout = setTimeout(_clearTimer, 1000)\n  if (typeof timeout.unref === 'function') timeout.unref()\n  return _timer\n}\n\nfunction _clearTimer () {\n  _timer = undefined\n}\n\nmodule.exports = StorageMemory\n","'use strict'\n\nconst { isServerSide } = require('../util')\n\nlet StorageRedis\nif (isServerSide) {\n  StorageRedis = require('./redis')\n}\nconst StorageMemory = require('./memory')\n\n/**\n * @typedef {StorageInterface} Storage\n */\n\n/**\n * @enum {string}\n */\nconst StorageOptionsType = {\n  redis: 'redis',\n  memory: 'memory'\n}\n\n/**\n * @typedef {Object} StorageOptions\n * @property {StorageOptionsType} type\n */\n\n/**\n * factory for storage, depending on type\n * @param {StorageOptionsType} type\n * @param {StorageMemoryOptions|StorageRedisOptions} options\n * @returns {StorageMemory|StorageRedis}\n */\nfunction createStorage (type, options) {\n  if (!isServerSide && type === StorageOptionsType.redis) {\n    throw new Error('Redis storage is not supported in the browser')\n  }\n\n  if (type === StorageOptionsType.redis) {\n    return new StorageRedis(options)\n  }\n  return new StorageMemory(options)\n}\n\nmodule.exports = createStorage\n","'use strict'\n\nconst stringify = require('safe-stable-stringify')\nconst StorageInterface = require('./interface')\nconst { findNotMatching, randomSubset, abstractLogging } = require('../util')\n\nconst GC_DEFAULT_CHUNK = 64\nconst GC_DEFAULT_LAZY_CHUNK = 64\nconst REFERENCES_DEFAULT_TTL = 60\n\n/**\n * @typedef StorageRedisOptions\n * @property {!store} client\n * @property {?Logger} log\n * @property {?Object|boolean} [invalidation=false]\n * @property {?number} [invalidation.referencesTTL=60]\n */\n\nclass StorageRedis extends StorageInterface {\n  /**\n   * @param {?StorageRedisOptions} options\n   */\n  constructor (options = {}) {\n    if (!options.client || typeof options.client !== 'object') {\n      throw new Error('Redis client is required')\n    }\n\n    super(options)\n\n    if (options.invalidation && options.invalidation.referencesTTL &&\n      (typeof options.invalidation.referencesTTL !== 'number' || options.invalidation.referencesTTL < 1)) {\n      throw new Error('invalidation.referencesTTL must be a positive integer greater than 1')\n    }\n\n    this.log = options.log || abstractLogging()\n    this.store = options.client\n    this.invalidation = !!options.invalidation\n    this.referencesTTL = (options.invalidation && options.invalidation.referencesTTL) || REFERENCES_DEFAULT_TTL\n  }\n\n  getReferenceKeyLabel (reference) {\n    return `r:${reference}`\n  }\n\n  getKeyReferenceLabel (key) {\n    return `k:${key}`\n  }\n\n  /**\n   * @param {string} key\n   * @returns {undefined|*} undefined if key not found\n   */\n  async get (key) {\n    this.log.debug({ msg: 'acd/storage/redis.get', key })\n\n    try {\n      const value = await this.store.get(key)\n      if (!value) {\n        if (!this.invalidation) {\n          return undefined\n        }\n\n        // clear references because the key could be expired (or evicted)\n        // note: no await\n        this.clearReferences(key)\n        return undefined\n      }\n      return JSON.parse(value)\n    } catch (err) {\n      this.log.error({ msg: 'acd/storage/redis.get error', err, key })\n    }\n  }\n\n  /**\n   * retrieve the remaining TTL value by key\n   * @param {string} key\n   * @returns {undefined|*} undefined if key not found or expired\n   */\n  async getTTL (key) {\n    this.log.debug({ msg: 'acd/storage/memory.getTTL', key })\n\n    let pttl = await this.store.pttl(key)\n    if (pttl < 0) {\n      return 0\n    }\n\n    pttl = Math.ceil(pttl / 1000)\n\n    return pttl\n  }\n\n  /**\n   * set value by key\n   * @param {string} key\n   * @param {*} value\n   * @param {number} ttl - ttl in seconds; zero means key will not be stored\n   * @param {?string[]} references\n   */\n  async set (key, value, ttl, references) {\n    // TODO validate keys, can't contain * or other special chars\n    this.log.debug({ msg: 'acd/storage/redis.set key', key, value, ttl, references })\n\n    ttl = Number(ttl)\n    if (!ttl || ttl < 0) {\n      return\n    }\n\n    try {\n      await this.store.set(key, stringify(value), 'EX', ttl)\n\n      if (!references || references.length < 1) {\n        return\n      }\n\n      if (!this.invalidation) {\n        this.log.warn({ msg: 'acd/storage/redis.set, invalidation is disabled, references are useless', key, references })\n        return\n      }\n\n      const writes = []\n\n      // clear old references\n      const currentReferences = await this.store.smembers(this.getKeyReferenceLabel(key))\n      this.log.debug({ msg: 'acd/storage/redis.set current references', key, currentReferences })\n      if (currentReferences.length > 1) {\n        currentReferences.sort()\n        references.sort()\n        const referencesToRemove = findNotMatching(references, currentReferences)\n\n        // remove key in current references\n        for (const reference of referencesToRemove) {\n          writes.push(['srem', this.getReferenceKeyLabel(reference), key])\n        }\n        writes.push(['del', this.getKeyReferenceLabel(key)])\n      }\n\n      // TODO we can probably get referencesToAdd and referencesToRemove in a single loop\n      const referencesToAdd = currentReferences.length > 1 ? findNotMatching(currentReferences, references) : references\n      this.log.debug({ msg: 'acd/storage/redis.set references to add', key, referencesToAdd })\n\n      for (let i = 0; i < referencesToAdd.length; i++) {\n        const reference = referencesToAdd[i]\n        const referenceKeyLabel = this.getReferenceKeyLabel(reference)\n        // reference->keys\n        writes.push(['sadd', referenceKeyLabel, key])\n        // reset reference->keys ttl to max\n        writes.push(['expire', referenceKeyLabel, this.referencesTTL])\n      }\n      const keyReferenceLabel = this.getKeyReferenceLabel(key)\n      // key-references\n      writes.push(['sadd', keyReferenceLabel, references])\n      // key-references has the same ttl of key\n      writes.push(['expire', keyReferenceLabel, ttl])\n\n      this.log.debug({ msg: 'acd/storage/redis.set references writes', writes })\n\n      await this.store.pipeline(writes).exec()\n    } catch (err) {\n      this.log.error({ msg: 'acd/storage/redis.set error', err, key, ttl, references })\n    }\n  }\n\n  /**\n   * remove an entry by key\n   * @param {string} key\n   * @returns {boolean} indicates if key was removed\n   */\n  async remove (key) {\n    this.log.debug({ msg: 'acd/storage/redis.remove', key })\n    try {\n      const removed = await this.store.del(key) > 0\n      if (removed && this.invalidation) { await this.clearReferences(key) }\n      return removed\n    } catch (err) {\n      this.log.error({ msg: 'acd/storage/redis.remove error', err, key })\n    }\n  }\n\n  /**\n   * @param {string|string[]} references\n   * @returns {string[]} removed keys\n   */\n  async invalidate (references) {\n    if (!this.invalidation) {\n      this.log.warn({ msg: 'acd/storage/redis.invalidate, exit due invalidation is disabled' })\n      return []\n    }\n\n    this.log.debug({ msg: 'acd/storage/redis.invalidate', references })\n\n    try {\n      if (Array.isArray(references)) {\n        return await this._invalidateReferences(references)\n      }\n      return await this._invalidateReference(references)\n    } catch (err) {\n      this.log.error({ msg: 'acd/storage/redis.invalidate error', err, references })\n      return []\n    }\n  }\n\n  /**\n   * @param {string[]} references\n   * @param {[bool=true]} mapReferences\n   * @returns {string[]} removed keys\n   */\n  async _invalidateReferences (references, mapReferences = true) {\n    const reads = references.map(reference => ['smembers', mapReferences ? this.getReferenceKeyLabel(reference) : reference])\n    const keys = await this.store.pipeline(reads).exec()\n\n    this.log.debug({ msg: 'acd/storage/redis._invalidateReferences keys', keys })\n\n    const writes = []\n    const removed = []\n    for (let i = 0; i < keys.length; i++) {\n      const key0 = keys[i][1]\n      if (!key0) { continue }\n      this.log.debug({ msg: 'acd/storage/redis._invalidateReferences got keys to be invalidated', keys: key0 })\n      for (let j = 0; j < key0.length; j++) {\n        const key1 = key0[j]\n        this.log.debug({ msg: 'acd/storage/redis._invalidateReferences del key' + key1 })\n        removed.push(key1)\n        writes.push(['del', key1])\n      }\n    }\n\n    await this.store.pipeline(writes).exec()\n    await this.clearReferences(removed)\n    return removed\n  }\n\n  /**\n   * @param {string} reference\n   * @returns {string[]} removed keys\n   */\n  async _invalidateReference (reference) {\n    let keys\n    if (reference.includes('*')) {\n      const references = await this.store.keys(this.getReferenceKeyLabel(reference))\n      return this._invalidateReferences(references, false)\n    } else {\n      keys = await this.store.smembers(this.getReferenceKeyLabel(reference))\n    }\n\n    this.log.debug({ msg: 'acd/storage/redis._invalidateReference keys', keys })\n\n    const writes = []\n    const removed = []\n    for (let i = 0; i < keys.length; i++) {\n      const key0 = keys[i]\n      this.log.debug({ msg: 'acd/storage/redis._invalidateReference del key' + key0 })\n      removed.push(key0)\n      writes.push(['del', key0])\n    }\n\n    await this.store.pipeline(writes).exec()\n    await this.clearReferences(removed)\n    return removed\n  }\n\n  /**\n   * @param {string} name\n   */\n  async clear (name) {\n    this.log.debug({ msg: 'acd/storage/redis.clear', name })\n\n    try {\n      if (!name) {\n        await this.store.flushall()\n        return\n      }\n\n      const keys = await this.store.keys(`${name}*`)\n      this.log.debug({ msg: 'acd/storage/redis.clear keys', keys })\n\n      const removes = keys.map(key => ['del', key])\n      await this.store.pipeline(removes).exec()\n\n      if (!this.invalidation) { return }\n      await this.clearReferences(keys)\n    } catch (err) {\n      this.log.error({ msg: 'acd/storage/redis.clear error', err, name })\n    }\n  }\n\n  async refresh () {\n    try {\n      await this.store.flushall()\n    } catch (err) {\n      this.log.error({ msg: 'acd/storage/redis.refresh error', err })\n    }\n  }\n\n  /**\n   * note: does not throw on error\n   * @param {string|string[]} keys\n   */\n  async clearReferences (keys) {\n    try {\n      if (!keys) {\n        this.log.warn({ msg: 'acd/storage/redis.clearReferences invalid call due to empty key' })\n        return\n      }\n\n      if (!Array.isArray(keys)) { keys = [keys] }\n\n      const reads = keys.map(key => ['smembers', this.getKeyReferenceLabel(key)])\n      const referencesKeys = await this.store.pipeline(reads).exec()\n\n      this.log.debug({ msg: 'acd/storage/redis.clearReferences references', keys, referencesKeys })\n\n      const writes = {}\n      for (let i = 0; i < keys.length; i++) {\n        for (let j = 0; j < referencesKeys[i][1].length; j++) {\n          const reference = this.getReferenceKeyLabel(referencesKeys[i][1][j])\n          if (writes[reference]) { continue }\n          writes[reference] = ['srem', reference, keys]\n        }\n        const key = this.getKeyReferenceLabel(keys[i])\n        writes[key] = ['del', key]\n      }\n\n      this.log.debug({ msg: 'acd/storage/redis.clearReferences writes pipeline', writes })\n      await this.store.pipeline(Object.values(writes)).exec()\n    } catch (err) {\n      this.log.error({ msg: 'acd/storage/redis.clearReferences error', err })\n    }\n  }\n\n  /**\n   * scan references and clean expired/evicted keys\n   * @param {?string} [mode=lazy] lazy or strict\n   * - in lazy mode, only `options.max` references are scanned every time, picking keys to check randomly\n   *   so this operation is lighter while does not ensure references full clean up\n   * - in strict mode, all references and keys are checked\n   *   this operation scan the whole db and is slow\n   * @param {?object} options\n   * @param {number} [options.chunk=64] number of references to retrieve at once\n   * @param {number|undefined} [options.lazy.cursor] cursor to start the scan; should be last cursor returned by scan; default start from the beginning\n   * @param {number} [lazyChunk=64] number of references to check per gc cycle\n   * @return {Object} report information of the operation\n   *   references scanned/removed, keys scanned/removed, loops, cursor, error if any\n   */\n  async gc (mode = 'lazy', options = {}) {\n    this.log.debug({ msg: 'acd/storage/redis.gc', mode, options })\n\n    if (!this.invalidation) {\n      this.log.warn({ msg: 'acd/storage/redis.gc does not run due to invalidation is disabled' })\n      return\n    }\n\n    if (mode !== 'strict' && mode !== 'lazy') { mode = 'lazy' }\n    const report = {\n      references: { scanned: [], removed: [] },\n      keys: { scanned: new Set(), removed: new Set() },\n      loops: 0,\n      cursor: 0,\n      error: null\n    }\n\n    try {\n      let cursor = 0\n      let lazyChunk = GC_DEFAULT_LAZY_CHUNK\n\n      if (options.chunk && (typeof options.chunk !== 'number' || options.chunk < 1)) {\n        report.error = new Error('chunk must be a positive integer greater than 1')\n        return report\n      }\n\n      if (options.lazy) {\n        if (options.lazy.chunk) {\n          if (typeof options.lazy.chunk !== 'number' || options.lazy.chunk < 1) {\n            report.error = new Error('lazy.chunk must be a positive integer greater than 1')\n            return report\n          }\n          lazyChunk = options.lazy.chunk\n        }\n        if (options.lazy.cursor) {\n          if (typeof options.lazy.cursor !== 'number' || options.lazy.cursor < 0) {\n            report.error = new Error('lazy.cursor must be a positive integer greater than 0')\n            return report\n          }\n          cursor = options.lazy.cursor\n        }\n      }\n\n      const chunk = options.chunk || GC_DEFAULT_CHUNK\n      const scanCount = Math.min(lazyChunk, chunk)\n      const startingCursor = cursor\n\n      let lastScanLength = -1\n      let lastRemoved = -1\n      do {\n        report.loops++\n\n        const scan = await this.store.scan(cursor, 'match', 'r:*', 'count', scanCount)\n        cursor = Number(scan[0])\n        lastScanLength = scan[1].length\n\n        const references = mode === 'lazy'\n          ? randomSubset(scan[1], lazyChunk)\n          : scan[1]\n\n        report.references.scanned = report.references.scanned.concat(references)\n\n        let reads = []\n        for (let i = 0; i < references.length; i++) {\n          const reference = references[i]\n          reads.push(['smembers', reference])\n        }\n        const referencesKeys = await this.store.pipeline(reads).exec()\n\n        const keysMap = {}\n        const referencesKeysMap = {}\n        for (let i = 0; i < referencesKeys.length; i++) {\n          const keys = referencesKeys[i]\n          const reference = references[i]\n          referencesKeysMap[reference] = keys[1]\n          for (let j = 0; j < keys[1].length; j++) {\n            const key = keys[1][j]\n            if (!keysMap[key]) {\n              keysMap[key] = [reference]\n            } else {\n              keysMap[key].push(reference)\n            }\n\n            report.keys.scanned.add(key)\n          }\n        }\n\n        const keys = Object.keys(keysMap)\n        reads = keys.map(key => ['exists', key])\n        const existingKeys = await this.store.pipeline(reads).exec()\n\n        const removingKeys = {}\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i]\n          if (existingKeys[i][1] === 1) { continue }\n\n          for (let j = 0; j < keysMap[key].length; j++) {\n            const reference = keysMap[key][j]\n            if (!removingKeys[reference]) {\n              removingKeys[reference] = [key]\n            } else {\n              removingKeys[reference].push(key)\n            }\n\n            report.keys.removed.add(key)\n          }\n        }\n\n        const writeReferences = Object.keys(removingKeys)\n        const writes = []\n        for (let i = 0; i < writeReferences.length; i++) {\n          const reference = writeReferences[i]\n          if (referencesKeysMap[reference].length === removingKeys[reference].length) {\n            writes.push(['del', reference])\n            report.references.removed.push(reference)\n          } else {\n            writes.push(['srem', reference, removingKeys[reference]])\n          }\n        }\n        await this.store.pipeline(writes).exec()\n        lastRemoved = writes.length\n\n        if (mode === 'lazy' && report.references.scanned.length >= lazyChunk) {\n          break\n        }\n      } while (startingCursor !== cursor && lastScanLength > 0 && lastRemoved > 0)\n\n      report.cursor = cursor\n      report.keys.scanned = Array.from(report.keys.scanned)\n      report.keys.removed = Array.from(report.keys.removed)\n    } catch (err) {\n      this.log.error({ msg: 'acd/storage/redis.gc error', err })\n      report.error = err\n    }\n    return report\n  }\n}\n\nmodule.exports = StorageRedis\n","'use strict'\n\nconst { kValues, kStorage, kStorages, kTransfromer, kTTL, kOnDedupe, kOnError, kOnHit, kOnMiss, kStale } = require('./symbol')\nconst stringify = require('safe-stable-stringify')\nconst createStorage = require('./storage')\n\nclass Cache {\n  /**\n   * @param {!Object} opts\n   * @param {!Storage} opts.storage - the storage to use\n   * @param {?Object} opts.transformer - the transformer to use\n   * @param {?number} [opts.ttl=0] - in seconds; default is 0 seconds, so it only does dedupe without cache\n   * @param {?function} opts.onDedupe\n   * @param {?function} opts.onError\n   * @param {?function} opts.onHit\n   * @param {?function} opts.onMiss\n   */\n  constructor (options = {}) {\n    if (!options.storage) {\n      throw new Error('storage is required')\n    }\n\n    // ttl _may_ be a function to defer the ttl decision until later\n    if (options.ttl && typeof options.ttl === 'number' && (options.ttl < 0 || !Number.isInteger(options.ttl))) {\n      throw new Error('ttl must be a positive integer greater than 0')\n    }\n\n    if (options.onDedupe && typeof options.onDedupe !== 'function') {\n      throw new Error('onDedupe must be a function')\n    }\n\n    if (options.onError && typeof options.onError !== 'function') {\n      throw new Error('onError must be a function')\n    }\n\n    if (options.onHit && typeof options.onHit !== 'function') {\n      throw new Error('onHit must be a function')\n    }\n\n    if (options.onMiss && typeof options.onMiss !== 'function') {\n      throw new Error('onMiss must be a function')\n    }\n\n    // stale _may_ be a function to defer the stale decision until later\n    if (typeof options.stale === 'number' && !(Math.floor(options.stale) === options.stale && options.stale >= 0)) {\n      throw new Error('stale must be an integer greater or equal to 0')\n    }\n\n    this[kValues] = {}\n\n    this[kStorage] = options.storage\n    this[kStorages] = new Map()\n    this[kStorages].set('_default', options.storage)\n\n    this[kTransfromer] = options.transformer\n\n    this[kTTL] = options.ttl || 0\n    this[kOnDedupe] = options.onDedupe || noop\n    this[kOnError] = options.onError || noop\n    this[kOnHit] = options.onHit || noop\n    this[kOnMiss] = options.onMiss || noop\n    this[kStale] = options.stale || 0\n  }\n\n  /**\n   * add a new function to dedupe (and cache)\n   * @param {!string} name name of the function\n   * @param {?Object} [opts]\n   * @param {?Object} [opts.storage] storage to use; default is the main one\n   * @param {?Object} opts.transformer - the transformer to use\n   * @param {?number} [opts.ttl] ttl for the results; default ttl is the one passed to the constructor\n   * @param {?function} [opts.onDedupe] function to call on dedupe; default is the one passed to the constructor\n   * @param {?function} [opts.onError] function to call on error; default is the one passed to the constructor\n   * @param {?function} [opts.onHit] function to call on hit; default is the one passed to the constructor\n   * @param {?function} [opts.onMiss] function to call on miss; default is the one passed to the constructor\n   * @param {?function} [opts.serialize] custom function to serialize the arguments of `func`, in order to create the key for deduping and caching\n   * @param {?function} [opts.references] function to generate references\n   * @param {!function} func the function to dedupe (and cache)\n   **/\n  define (name, opts, func) {\n    if (typeof opts === 'function') {\n      func = opts\n      opts = {}\n    }\n\n    if (name && this[name]) {\n      throw new Error(`${name} is already defined in the cache or it is a forbidden name`)\n    }\n\n    opts = opts || {}\n\n    if (typeof func !== 'function') {\n      throw new TypeError(`Missing the function parameter for '${name}'`)\n    }\n\n    const serialize = opts.serialize\n    if (serialize && typeof serialize !== 'function') {\n      throw new TypeError('serialize must be a function')\n    }\n\n    const references = opts.references\n    if (references && typeof references !== 'function') {\n      throw new TypeError('references must be a function')\n    }\n\n    if (typeof opts.ttl !== 'function') {\n      if (opts.ttl && (typeof opts.ttl !== 'number' || opts.ttl < 0 || !Number.isInteger(opts.ttl))) {\n        throw new Error('ttl must be a positive integer greater than 0')\n      }\n    }\n\n    let storage\n    if (opts.storage) {\n      storage = createStorage(opts.storage.type, opts.storage.options)\n      this[kStorages].set(name, storage)\n    } else {\n      storage = this[kStorage]\n    }\n\n    const ttl = opts.ttl !== undefined ? opts.ttl : this[kTTL]\n    const stale = opts.stale !== undefined ? opts.stale : this[kStale]\n    const onDedupe = opts.onDedupe || this[kOnDedupe]\n    const onError = opts.onError || this[kOnError]\n    const onHit = opts.onHit || this[kOnHit]\n    const onMiss = opts.onMiss || this[kOnMiss]\n    const transformer = opts.transformer || this[kTransfromer]\n\n    const wrapper = new Wrapper(func, name, serialize, references, storage, transformer, ttl, onDedupe, onError, onHit, onMiss, stale)\n\n    this[kValues][name] = wrapper\n    this[name] = wrapper.add.bind(wrapper)\n    return this\n  }\n\n  async clear (name, value) {\n    if (name) {\n      if (!this[kValues][name]) {\n        throw new Error(`${name} is not defined in the cache`)\n      }\n\n      await this[kValues][name].clear(value)\n      return\n    }\n\n    const clears = []\n    for (const wrapper of Object.values(this[kValues])) {\n      clears.push(wrapper.clear())\n    }\n    await Promise.all(clears)\n  }\n\n  async get (name, key) {\n    if (!this[kValues][name]) {\n      throw new Error(`${name} is not defined in the cache`)\n    }\n\n    // TODO validate key?\n\n    return this[kValues][name].get(key)\n  }\n\n  async set (name, key, value, ttl, references) {\n    if (!this[kValues][name]) {\n      throw new Error(`${name} is not defined in the cache`)\n    }\n\n    // TODO validate key, value, ttl, references?\n\n    return this[kValues][name].set(key, value, ttl, references)\n  }\n\n  async invalidate (name, references) {\n    if (!this[kValues][name]) {\n      throw new Error(`${name} is not defined in the cache`)\n    }\n\n    return this[kValues][name].invalidate(references)\n  }\n\n  async invalidateAll (references, storage = '_default') {\n    if (!this[kStorages].has(storage)) {\n      throw new Error(`${storage} storage is not defined in the cache`)\n    }\n    const s = this[kStorages].get(storage)\n    await s.invalidate(references)\n  }\n}\n\nclass Wrapper {\n  /**\n   * @param {function} func\n   * @param {string} name\n   * @param {function} serialize\n   * @param {function} references\n   * @param {Storage} storage\n   * @param {Object} transformer\n   * @param {number} ttl\n   * @param {function} onDedupe\n   * @param {function} onError\n   * @param {function} onHit\n   * @param {function} onMiss\n   * @param {stale} ttl\n   */\n  constructor (func, name, serialize, references, storage, transformer, ttl, onDedupe, onError, onHit, onMiss, stale) {\n    this.dedupes = new Map()\n    this.func = func\n    this.name = name\n    this.serialize = serialize\n    this.references = references\n\n    this.storage = storage\n    this.transformer = transformer\n    this.ttl = ttl\n    this.onDedupe = onDedupe\n    this.onError = onError\n    this.onHit = onHit\n    this.onMiss = onMiss\n    this.stale = stale\n  }\n\n  getKey (args) {\n    const id = this.serialize ? this.serialize(args) : args\n    return typeof id === 'string' ? id : stringify(id)\n  }\n\n  getStorageKey (key) {\n    return `${this.name}~${key}`\n  }\n\n  getStorageName () {\n    return `${this.name}~`\n  }\n\n  add (args) {\n    try {\n      const key = this.getKey(args)\n\n      let query = this.dedupes.get(key)\n      if (!query) {\n        query = new Query()\n        this.buildPromise(query, args, key)\n        this.dedupes.set(key, query)\n      } else {\n        this.onDedupe(key)\n      }\n\n      return query.promise\n    } catch (err) {\n      this.onError(err)\n    }\n  }\n\n  /**\n   * wrap the original func to sync storage\n   */\n  async wrapFunction (args, key) {\n    const storageKey = this.getStorageKey(key)\n    if (this.ttl > 0 || typeof this.ttl === 'function') {\n      const data = await this.get(storageKey)\n\n      if (data !== undefined) {\n        this.onHit(key)\n        const stale = typeof this.stale === 'function' ? this.stale(data) : this.stale\n        if (stale > 0) {\n          const remainingTTL = await this.storage.getTTL(storageKey)\n          if (remainingTTL <= stale) {\n            this._wrapFunction(storageKey, args, key).catch(noop)\n          }\n        }\n        return data\n      } else {\n        this.onMiss(key)\n      }\n    }\n\n    return this._wrapFunction(storageKey, args, key)\n  }\n\n  async _wrapFunction (storageKey, args, key) {\n    const result = await this.func(args, key)\n    const stale = typeof this.stale === 'function' ? this.stale(result) : this.stale\n    let ttl = typeof this.ttl === 'function' ? this.ttl(result) : this.ttl\n    if (ttl === undefined || ttl === null || (typeof ttl !== 'number' || !Number.isInteger(ttl))) {\n      this.onError(new Error('ttl must be an integer'))\n      return result\n    }\n    ttl += stale\n    if (ttl < 1) {\n      return result\n    }\n\n    if (!this.references) {\n      await this.set(storageKey, result, ttl)\n      return result\n    }\n\n    try {\n      let references = this.references(args, key, result)\n      let value = result\n      if (references && typeof references.then === 'function') { references = await references }\n      if (this.transformer) {\n        value = this.transformer.serialize(result)\n      }\n      // TODO validate references?\n      await this.storage.set(storageKey, value, ttl, references)\n    } catch (err) {\n      this.onError(err)\n    }\n\n    return result\n  }\n\n  buildPromise (query, args, key) {\n    query.promise = this.wrapFunction(args, key)\n\n    // we fork the promise chain on purpose\n    query.promise\n      .then(result => {\n        // clear the dedupe once done\n        this.dedupes.delete(key)\n        return result\n      })\n      .catch(err => {\n        this.onError(err)\n        this.dedupes.delete(key)\n        // TODO option to remove key from storage on error?\n        // we may want to relay on cache if the original function got error\n        // then we probably need more option for that\n        const r = this.storage.remove(this.getStorageKey(key))\n        if (r && typeof r.catch === 'function') { r.catch(noop) }\n      })\n  }\n\n  async clear (value) {\n    // TODO validate value?\n    if (value) {\n      const key = this.getKey(value)\n      this.dedupes.delete(key)\n      await this.storage.remove(this.getStorageKey(key))\n      return\n    }\n    await this.storage.clear(this.getStorageName())\n    this.dedupes.clear()\n  }\n\n  async get (key) {\n    const data = await this.storage.get(key)\n    if (this.transformer && !!data) {\n      return await this.transformer.deserialize(data)\n    }\n    return data\n  }\n\n  async set (key, value, ttl, references) {\n    if (this.transformer) {\n      value = this.transformer.serialize(value)\n    }\n    return this.storage.set(key, value, ttl, references)\n  }\n\n  async invalidate (references) {\n    return this.storage.invalidate(references)\n  }\n}\n\nclass Query {\n  constructor () {\n    this.promise = null\n  }\n}\n\nfunction noop () { }\n\nmodule.exports.Cache = Cache\n","const { Cache } = require('./src/cache')\nconst createStorage = require('./src/storage')\n\n/**\n   * @param {!Object} options\n   * @param {!Object} [options.storage] - the storage to use; default is `{ type: 'memory' }`\n   * @param {?number} [options.ttl=0] - in seconds; default is 0 seconds, so it only does dedupe without cache\n   * @param {?function} options.onDedupe\n   * @param {?function} options.onHit\n   * @param {?function} options.onMiss\n   */\nfunction createCache (options) {\n  if (!options) {\n    options = { storage: { type: 'memory' } }\n  } else if (!options.storage) {\n    options.storage = { type: 'memory' }\n  }\n  const storage = createStorage(options.storage.type, options.storage.options)\n  return new Cache({\n    ...options,\n    storage\n  })\n}\n\nmodule.exports = {\n  Cache,\n  createCache,\n  createStorage\n}\n","let tasks = 0\nlet resolves = []\n\nexport function startTask() {\n  tasks += 1\n  return () => {\n    tasks -= 1\n    if (tasks === 0) {\n      let prevResolves = resolves\n      resolves = []\n      for (let i of prevResolves) i()\n    }\n  }\n}\n\nexport function task(cb) {\n  let endTask = startTask()\n  let promise = cb().finally(endTask)\n  promise.t = true\n  return promise\n}\n\nexport function allTasks() {\n  if (tasks === 0) {\n    return Promise.resolve()\n  } else {\n    return new Promise(resolve => {\n      resolves.push(resolve)\n    })\n  }\n}\n\nexport function cleanTasks() {\n  tasks = 0\n}\n","import { cleanTasks } from '../task/index.js'\n\nexport let clean = Symbol('clean')\n\nexport let cleanStores = (...stores) => {\n  if (process.env.NODE_ENV === 'production') {\n    throw new Error(\n      'cleanStores() can be used only during development or tests'\n    )\n  }\n  cleanTasks()\n  for (let $store of stores) {\n    if ($store) {\n      if ($store.mocked) delete $store.mocked\n      if ($store[clean]) $store[clean]()\n    }\n  }\n}\n","import { clean } from '../clean-stores/index.js'\n\nlet listenerQueue = []\n\nexport let atom = (initialValue, level) => {\n  let listeners = []\n  let $atom = {\n    get() {\n      if (!$atom.lc) {\n        $atom.listen(() => {})()\n      }\n      return $atom.value\n    },\n    l: level || 0,\n    lc: 0,\n    listen(listener, listenerLevel) {\n      $atom.lc = listeners.push(listener, listenerLevel || $atom.l) / 2\n\n      return () => {\n        let index = listeners.indexOf(listener)\n        if (~index) {\n          listeners.splice(index, 2)\n          if (!--$atom.lc) $atom.off()\n        }\n      }\n    },\n    notify(oldValue, changedKey) {\n      let runListenerQueue = !listenerQueue.length\n      for (let i = 0; i < listeners.length; i += 2) {\n        listenerQueue.push(\n          listeners[i],\n          listeners[i + 1],\n          $atom.value,\n          oldValue,\n          changedKey\n        )\n      }\n\n      if (runListenerQueue) {\n        for (let i = 0; i < listenerQueue.length; i += 5) {\n          let skip\n          for (let j = i + 1; !skip && (j += 5) < listenerQueue.length; ) {\n            if (listenerQueue[j] < listenerQueue[i + 1]) {\n              skip = listenerQueue.push(\n                listenerQueue[i],\n                listenerQueue[i + 1],\n                listenerQueue[i + 2],\n                listenerQueue[i + 3],\n                listenerQueue[i + 4]\n              )\n            }\n          }\n\n          if (!skip) {\n            listenerQueue[i](\n              listenerQueue[i + 2],\n              listenerQueue[i + 3],\n              listenerQueue[i + 4]\n            )\n          }\n        }\n        listenerQueue.length = 0\n      }\n    },\n    /* It will be called on last listener unsubscribing.\n       We will redefine it in onMount and onStop. */\n    off() {},\n    set(newValue) {\n      let oldValue = $atom.value\n      if (oldValue !== newValue) {\n        $atom.value = newValue\n        $atom.notify(oldValue)\n      }\n    },\n    subscribe(listener, listenerLevel) {\n      let unbind = $atom.listen(listener, listenerLevel)\n      listener($atom.value)\n      return unbind\n    },\n    value: initialValue\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    $atom[clean] = () => {\n      listeners = []\n      $atom.lc = 0\n      $atom.off()\n    }\n  }\n\n  return $atom\n}\n","/** @internal */\nexport const runtime = typeof document === 'undefined' ? 'server' : 'browser'\n","import type {ClientPerspective, ContentSourceMap, QueryParams, SanityClient} from '@sanity/client'\nimport type {SanityStegaClient} from '@sanity/client/stega'\nimport {type Cache, createCache} from 'async-cache-dedupe'\nimport {atom, map, type MapStore, onMount, startTask} from 'nanostores'\n\nimport {runtime} from './env'\nimport {defineEnableLiveMode} from './live-mode'\nimport type {EnableLiveMode, Fetcher, QueryStoreState} from './types'\n\nexport type {MapStore}\n\nexport type * from './types'\nexport type {WritableAtom} from 'nanostores'\n\n/** @public */\nexport interface CreateQueryStoreOptions {\n  /**\n   * The Sanity client to use for fetching data, or `false` if `ssr: true` and it's set with `setServerClient` later\n   * You may use any client that is an `instanceof SanityClient` or `instanceof SanityStegaClient`.\n   * @example `import {createClient} from '@sanity/client'`\n   * @example `import {createClient} from '@sanity/client/stega'`\n   * @example `import {createClient} from '@sanity/preview-kit/client'`\n   * @example `import {createClient} from 'next-sanity'`\n   */\n  client: SanityClient | SanityStegaClient | false\n  /**\n   * If you want all data fetching to be done server-side in production, set this to `true` and `client: false`.\n   * Then, in your server entry file, you can set the Sanity client with `setServerClient`.\n   */\n  ssr?: boolean\n  /** @internal */\n  tag?: string\n}\n\n/** @public */\nexport interface QueryStore {\n  createFetcherStore: <QueryResponseResult = unknown, QueryResponseError = unknown>(\n    query: string,\n    params?: QueryParams,\n    /**\n     * Initial `data` and `sourceMap`, used with SSR hydration and is required if `ssr: true`\n     * and an optional speed optimization if `ssr: false`\n     */\n    initial?: {\n      data: QueryResponseResult\n      sourceMap?: ContentSourceMap\n      perspective?: ClientPerspective\n    },\n  ) => MapStore<QueryStoreState<QueryResponseResult, QueryResponseError>>\n  /**\n   * When `ssr: true` you call this in your server entry point that imports the result of `createQueryStore` instance.\n   * It's required to call it before any data fetching is done.\n   */\n  setServerClient: (client: SanityClient | SanityStegaClient) => void\n  enableLiveMode: EnableLiveMode\n  /** @internal */\n  unstable__cache: {\n    instance: Cache & {\n      fetch: <QueryResponseResult>(key: string) => Promise<{\n        result: QueryResponseResult\n        resultSourceMap: ContentSourceMap | undefined\n      }>\n    }\n  }\n  /** @internal */\n  unstable__serverClient: {\n    /**\n     * Only set if `ssr: true` and `setServerClient` has been called.\n     */\n    instance: SanityClient | undefined\n    /**\n     * Will be `true` if the client given to `setServerClient` has a token configured.\n     */\n    canPreviewDrafts?: boolean\n  }\n}\n\nfunction cloneClientWithConfig(newClient: SanityClient): SanityClient {\n  return newClient.withConfig({\n    allowReconfigure: false,\n  })\n}\n\n/** @public */\nexport const createQueryStore = (options: CreateQueryStoreOptions): QueryStore => {\n  const {ssr = false, tag = 'core-loader'} = options\n  if (ssr && options.client) {\n    throw new TypeError(\n      '`client` option is not allowed when `ssr: true`, use `setServerClient` from your server entry point instead',\n    )\n  }\n  if (!ssr && options.client === false) {\n    throw new TypeError(`You must set \\`ssr: true\\` when \\`client: false\\` is used`)\n  }\n  if (!ssr && !options.client) {\n    throw new TypeError(`\\`client\\` is required`)\n  }\n  let client = ssr ? undefined : cloneClientWithConfig(options.client as SanityClient)\n\n  function createDefaultCache(client: SanityClient | undefined) {\n    return createCache().define('fetch', async (key: string) => {\n      if (!client) {\n        throw new Error(\n          `You have to set the Sanity client with \\`setServerClient\\` before any data fetching is done`,\n        )\n      }\n      const {query, params = {}, perspective, useCdn} = JSON.parse(key)\n      const {result, resultSourceMap} = await client.fetch(query, params, {\n        tag,\n        filterResponse: false,\n        perspective,\n        useCdn,\n      })\n      return {result, resultSourceMap}\n    })\n  }\n\n  function createDefaultFetcher(): Fetcher {\n    const initialPerspective = client?.config().perspective || 'published'\n\n    unstable__cache.instance = createDefaultCache(client)\n\n    return {\n      hydrate: (_query, _params, initial) => ({\n        loading: initial?.data === undefined || initial?.sourceMap === undefined,\n        error: undefined,\n        data: initial?.data,\n        sourceMap: initial?.sourceMap,\n        perspective: initialPerspective,\n      }),\n      fetch: (query, params, $fetch, controller) => {\n        if (controller.signal.aborted) return\n\n        const finishTask = startTask()\n\n        $fetch.setKey('loading', true)\n        $fetch.setKey('error', undefined)\n        unstable__cache\n          .instance!.fetch(JSON.stringify({query, params}))\n          .then((response) => {\n            if (controller.signal.aborted) return\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            $fetch.setKey('data', response.result as any)\n            $fetch.setKey('sourceMap', response.resultSourceMap)\n            $fetch.setKey('perspective', initialPerspective)\n          })\n          .catch((reason) => {\n            $fetch.setKey('error', reason)\n          })\n          .finally(() => {\n            $fetch.setKey('loading', false)\n            finishTask()\n          })\n      },\n    } satisfies Fetcher\n  }\n\n  const unstable__cache: QueryStore['unstable__cache'] = {\n    instance: createDefaultCache(client),\n  }\n\n  const $fetcher = atom<Fetcher | undefined>(client ? createDefaultFetcher() : undefined)\n\n  const enableLiveMode = defineEnableLiveMode({\n    client: client || undefined,\n    ssr,\n    setFetcher: (fetcher) => {\n      const originalFetcher = $fetcher.get()\n      $fetcher.set(fetcher)\n      return () => $fetcher.set(originalFetcher)\n    },\n  })\n\n  const createFetcherStore: QueryStore['createFetcherStore'] = <\n    QueryResponseResult,\n    QueryResponseError,\n  >(\n    query: string,\n    params: QueryParams = {},\n    initial?: Pick<\n      QueryStoreState<QueryResponseResult, QueryResponseError>,\n      'data' | 'sourceMap' | 'perspective'\n    >,\n  ): MapStore<QueryStoreState<QueryResponseResult, QueryResponseError>> => {\n    const fetcher = $fetcher.get()\n    const $fetch = map<QueryStoreState<QueryResponseResult, QueryResponseError>>(\n      fetcher\n        ? fetcher.hydrate(query, params, initial)\n        : {\n            loading: false,\n            error:\n              typeof initial?.data === 'undefined'\n                ? (new Error(\n                    `The \\`initial\\` option is required when \\`ssr: true\\``,\n                  ) as QueryResponseError)\n                : undefined,\n            data: initial?.data,\n            sourceMap: initial?.sourceMap,\n            perspective: initial?.perspective,\n          },\n    )\n\n    onMount($fetch, () => {\n      let controller = new AbortController()\n      const unsubscribe = $fetcher.subscribe((fetcher) => {\n        if (!fetcher || controller.signal.aborted) return\n        controller.abort()\n        controller = new AbortController()\n        fetcher.fetch(query, params, $fetch, controller)\n      })\n\n      return () => {\n        controller.abort()\n        unsubscribe()\n      }\n    })\n\n    return $fetch\n  }\n  const unstable__serverClient: QueryStore['unstable__serverClient'] = {\n    instance: undefined,\n    canPreviewDrafts: false,\n  }\n  const setServerClient: QueryStore['setServerClient'] = (newClient) => {\n    if (runtime !== 'server') {\n      throw new Error(\n        '`setServerClient` can only be called in server environments, detected: ' +\n          JSON.stringify(runtime),\n      )\n    }\n    if (!ssr) {\n      throw new Error('`setServerClient` can only be called when `ssr: true`')\n    }\n    unstable__serverClient.instance = client = cloneClientWithConfig(newClient as SanityClient)\n    unstable__serverClient.canPreviewDrafts = !!client.config().token\n    $fetcher.set(createDefaultFetcher())\n  }\n\n  return {\n    createFetcherStore,\n    enableLiveMode,\n    setServerClient,\n    unstable__cache,\n    unstable__serverClient,\n  }\n}\n\nexport {runtime} from './env'\n","import {runtime} from '../env'\nimport type {EnableLiveMode, EnableLiveModeOptions} from '../types'\nimport type {LazyEnableLiveModeOptions} from './enableLiveMode'\n\nexport const defineEnableLiveMode: (\n  config: Omit<LazyEnableLiveModeOptions, Exclude<keyof EnableLiveModeOptions, 'client'>>,\n) => EnableLiveMode = (config) => {\n  const {ssr, setFetcher} = config\n\n  return (options) => {\n    if (runtime === 'server') {\n      throw new Error('Live mode is not supported in server environments')\n    }\n    if (ssr && !options.client) {\n      throw new Error('The `client` option in `enableLiveMode` is required')\n    }\n\n    const client = options.client || config.client || undefined\n    const controller = new AbortController()\n    let disableLiveMode: (() => void) | undefined\n    import('./enableLiveMode').then(({enableLiveMode}) => {\n      if (controller.signal.aborted) return\n      disableLiveMode = enableLiveMode({...options, client, setFetcher, ssr})\n    })\n    return () => {\n      controller.abort()\n      disableLiveMode?.()\n    }\n  }\n}\n","import { atom } from '../atom/index.js'\n\nexport let map = (initial = {}) => {\n  let $map = atom(initial)\n\n  $map.setKey = function (key, value) {\n    let oldMap = $map.value\n    if (typeof value === 'undefined' && key in $map.value) {\n      $map.value = { ...$map.value }\n      delete $map.value[key]\n      $map.notify(oldMap, key)\n    } else if ($map.value[key] !== value) {\n      $map.value = {\n        ...$map.value,\n        [key]: value\n      }\n      $map.notify(oldMap, key)\n    }\n  }\n\n  return $map\n}\n","import { clean } from '../clean-stores/index.js'\n\nconst START = 0\nconst STOP = 1\nconst SET = 2\nconst NOTIFY = 3\nconst MOUNT = 5\nconst UNMOUNT = 6\nconst REVERT_MUTATION = 10\n\nexport let on = (object, listener, eventKey, mutateStore) => {\n  object.events = object.events || {}\n  if (!object.events[eventKey + REVERT_MUTATION]) {\n    object.events[eventKey + REVERT_MUTATION] = mutateStore(eventProps => {\n      // eslint-disable-next-line no-sequences\n      object.events[eventKey].reduceRight((event, l) => (l(event), event), {\n        shared: {},\n        ...eventProps\n      })\n    })\n  }\n  object.events[eventKey] = object.events[eventKey] || []\n  object.events[eventKey].push(listener)\n  return () => {\n    let currentListeners = object.events[eventKey]\n    let index = currentListeners.indexOf(listener)\n    currentListeners.splice(index, 1)\n    if (!currentListeners.length) {\n      delete object.events[eventKey]\n      object.events[eventKey + REVERT_MUTATION]()\n      delete object.events[eventKey + REVERT_MUTATION]\n    }\n  }\n}\n\nexport let onStart = ($store, listener) =>\n  on($store, listener, START, runListeners => {\n    let originListen = $store.listen\n    $store.listen = arg => {\n      if (!$store.lc && !$store.starting) {\n        $store.starting = true\n        runListeners()\n        delete $store.starting\n      }\n      return originListen(arg)\n    }\n    return () => {\n      $store.listen = originListen\n    }\n  })\n\nexport let onStop = ($store, listener) =>\n  on($store, listener, STOP, runListeners => {\n    let originOff = $store.off\n    $store.off = () => {\n      runListeners()\n      originOff()\n    }\n    return () => {\n      $store.off = originOff\n    }\n  })\n\nexport let onSet = ($store, listener) =>\n  on($store, listener, SET, runListeners => {\n    let originSet = $store.set\n    let originSetKey = $store.setKey\n    if ($store.setKey) {\n      $store.setKey = (changed, changedValue) => {\n        let isAborted\n        let abort = () => {\n          isAborted = true\n        }\n\n        runListeners({\n          abort,\n          changed,\n          newValue: { ...$store.value, [changed]: changedValue }\n        })\n        if (!isAborted) return originSetKey(changed, changedValue)\n      }\n    }\n    $store.set = newValue => {\n      let isAborted\n      let abort = () => {\n        isAborted = true\n      }\n\n      runListeners({ abort, newValue })\n      if (!isAborted) return originSet(newValue)\n    }\n    return () => {\n      $store.set = originSet\n      $store.setKey = originSetKey\n    }\n  })\n\nexport let onNotify = ($store, listener) =>\n  on($store, listener, NOTIFY, runListeners => {\n    let originNotify = $store.notify\n    $store.notify = (oldValue, changed) => {\n      let isAborted\n      let abort = () => {\n        isAborted = true\n      }\n\n      runListeners({ abort, changed, oldValue })\n      if (!isAborted) return originNotify(oldValue, changed)\n    }\n    return () => {\n      $store.notify = originNotify\n    }\n  })\n\nexport let STORE_UNMOUNT_DELAY = 1000\n\nexport let onMount = ($store, initialize) => {\n  let listener = payload => {\n    let destroy = initialize(payload)\n    if (destroy) $store.events[UNMOUNT].push(destroy)\n  }\n  return on($store, listener, MOUNT, runListeners => {\n    let originListen = $store.listen\n    $store.listen = (...args) => {\n      if (!$store.lc && !$store.active) {\n        $store.active = true\n        runListeners()\n      }\n      return originListen(...args)\n    }\n\n    let originOff = $store.off\n    $store.events[UNMOUNT] = []\n    $store.off = () => {\n      originOff()\n      setTimeout(() => {\n        if ($store.active && !$store.lc) {\n          $store.active = false\n          for (let destroy of $store.events[UNMOUNT]) destroy()\n          $store.events[UNMOUNT] = []\n        }\n      }, STORE_UNMOUNT_DELAY)\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      let originClean = $store[clean]\n      $store[clean] = () => {\n        for (let destroy of $store.events[UNMOUNT]) destroy()\n        $store.events[UNMOUNT] = []\n        $store.active = false\n        originClean()\n      }\n    }\n\n    return () => {\n      $store.listen = originListen\n      $store.off = originOff\n    }\n  })\n}\n"],"names":["cache","symbol","kValues","Symbol","kStorage","kStorages","kTransfromer","kTTL","kOnDedupe","kOnError","kOnHit","kOnMiss","kStale","hasOwnProperty","Object","prototype","stringify","configure","default","exports","module","strEscapeSequencesRegExp","strEscape","str","length","test","JSON","insertSort","array","sort","i","currentValue","position","typedArrayPrototypeGetSymbolToStringTag","getOwnPropertyDescriptor","getPrototypeOf","Int8Array","toStringTag","get","isTypedArrayWithEntries","value","call","stringifyTypedArray","separator","maximumBreadth","whitespace","res","getBooleanOption","options","key","TypeError","getPositiveIntegerOption","Number","isInteger","RangeError","getItemCount","number","fail","strict","message","toString","Error","getStrictOption","bigint","circularValue","getCircularValueOption","deterministic","maximumDepth","stringifyFnReplacer","parent","stack","replacer","spacer","indentation","toJSON","indexOf","join","originalIndentation","Array","isArray","push","maximumValuesToStringify","Math","min","tmp","String","pop","keys","keyLength","maximumPropertiesToStringify","isFinite","stringifyArrayReplacer","stringifyIndent","slice","stringifySimple","space","arguments","repeat","replacerArray","replacerSet","Set","add","getUniqueReplacerSet","randomNumber","max","random","util","findNotMatching","arrayA","arrayB","found","lastIndexB","indexA","indexB","findMatchingIndexes","bsearchIndex","start","end","index","wildcardMatch","content","j","randomSubset","size","limit","n","floor","indexes","result","abstractLogging","noop","fatal","error","warn","info","debug","trace","isServerSide","window","_interface","constructor","this","set","ttl","references","remove","invalidate","clear","name","refresh","Iterator","next","iterator","of","args","l","done","empty","fromSequence","sequence","is","support","ARRAY_BUFFER_SUPPORT","ArrayBuffer","SYMBOL_SUPPORT","require$$0","foreach","iterable","callback","k","s","isView","forEach","MAX_8BIT_INTEGER","pow","MAX_16BIT_INTEGER","MAX_32BIT_INTEGER","MAX_SIGNED_8BIT_INTEGER","MAX_SIGNED_16BIT_INTEGER","MAX_SIGNED_32BIT_INTEGER","getPointerArray","maxIndex","Uint8Array","Uint16Array","Uint32Array","getSignedPointerArray","Int16Array","Int32Array","Float64Array","getNumberType","sign","TYPE_PRIORITY","Float32Array","getMinimalRepresentation","getter","p","t","v","maxType","maxPriority","isTypedArray","concat","o","indices","typed","require$$1","guessLength","target","iterables","isArrayLike","toArray","forEach$1","toArrayWithIndices","IndexArray","require$$2","require$$3","LRUCache","Keys","Values","capacity","PointerArray","forward","backward","K","V","head","tail","items","splayOnTop","pointer","oldHead","previous","setpop","oldValue","oldKey","evicted","has","peek","scope","values","entries","inspect","step","proxy","Map","defineProperty","enumerable","for","from","StorageInterface","setImmediate","globalThis","fn","setTimeout","_timer","now","Date","timeout","_clearTimer","unref","memory","super","log","invalidation","init","store","keysReferences","referencesKeys","msg","entry","getTTL","existingKey","removed","_removeReferences","currentReferences","referencesToRemove","reference","splice","delete","referencesToAdd","_removeKey","_removeReferencesKeys","at","_invalidateReferences","_invalidateReference","includes","StorageRedis","redis","client","referencesTTL","getReferenceKeyLabel","getKeyReferenceLabel","clearReferences","parse","err","pttl","ceil","writes","smembers","referenceKeyLabel","keyReferenceLabel","pipeline","exec","del","mapReferences","reads","map","key0","key1","flushall","removes","gc","mode","report","scanned","loops","cursor","lazyChunk","chunk","lazy","scanCount","startingCursor","lastScanLength","lastRemoved","scan","keysMap","referencesKeysMap","existingKeys","removingKeys","writeReferences","StorageMemory","StorageOptionsType","storage","type","createStorage","Wrapper","func","serialize","transformer","onDedupe","onError","onHit","onMiss","stale","dedupes","getKey","id","getStorageKey","getStorageName","query","Query","buildPromise","promise","wrapFunction","storageKey","data","_wrapFunction","catch","then","r","deserialize","Cache","define","opts","wrapper","bind","clears","Promise","all","invalidateAll","asyncCacheDedupe","createCache","tasks","resolves","clean","listenerQueue","atom","initialValue","level","listeners","$atom","lc","listen","listener","listenerLevel","off","notify","changedKey","runListenerQueue","skip","newValue","subscribe","unbind","process","env","NODE_ENV","runtime","document","cloneClientWithConfig","newClient","withConfig","allowReconfigure","createQueryStore","ssr","tag","createDefaultCache","async","params","perspective","useCdn","resultSourceMap","fetch","filterResponse","createDefaultFetcher","initialPerspective","config","unstable__cache","instance","hydrate","_query","_params","initial","loading","sourceMap","$fetch","controller","signal","aborted","finishTask","prevResolves","setKey","response","reason","finally","$fetcher","enableLiveMode","setFetcher","AbortController","disableLiveMode","import","abort","defineEnableLiveMode","fetcher","originalFetcher","unstable__serverClient","canPreviewDrafts","createFetcherStore","$map","oldMap","initialize","unsubscribe","payload","destroy","$store","events","eventKey","mutateStore","runListeners","originListen","active","originOff","originClean","object","eventProps","reduceRight","event","shared","setServerClient","token"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,21,22]}