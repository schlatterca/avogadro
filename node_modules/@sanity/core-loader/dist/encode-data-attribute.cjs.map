{"version":3,"file":"encode-data-attribute.cjs","sources":["../src/encodeDataAttribute.ts"],"sourcesContent":["import {encodeSanityNodeData} from '@repo/visual-editing-helpers/csm'\nimport {\n  type ContentSourceMap,\n  jsonPathToStudioPath,\n  resolveEditInfo,\n  studioPath,\n  type StudioPathLike,\n  studioPathToJsonPath,\n} from '@sanity/client/csm'\nimport type {StegaConfig} from '@sanity/client/stega'\n\nimport type {EncodeDataAttribute} from './types'\n\n/** @public */\nexport const encodeDataAttribute: EncodeDataAttribute<unknown> = (\n  result,\n  sourceMap,\n  studioUrl,\n  studioPathLike,\n) => {\n  if (!sourceMap || !studioUrl) {\n    return undefined\n  }\n  const resultPath = studioPathToJsonPath(studioPathLike)\n\n  const editInfo = resolveEditInfo({\n    resultPath,\n    resultSourceMap: sourceMap,\n    studioUrl,\n  })\n  if (!editInfo) {\n    return undefined\n  }\n\n  return encodeSanityNodeData({\n    baseUrl: editInfo.baseUrl,\n    workspace: editInfo.workspace,\n    tool: editInfo.tool,\n    type: editInfo.type,\n    id: editInfo.id,\n    path:\n      typeof editInfo.path === 'string'\n        ? editInfo.path\n        : studioPath.toString(jsonPathToStudioPath(editInfo.path)),\n  })\n}\n\nexport type {EncodeDataAttribute}\n\n/**\n * @public\n */\nexport type EncodeDataAttributeFunction = {\n  (path: StudioPathLike): string | undefined\n  scope: (path: StudioPathLike) => EncodeDataAttributeFunction\n}\n\n/**\n * @public\n */\nexport function defineEncodeDataAttribute<QueryResponseResult = unknown>(\n  result: QueryResponseResult,\n  sourceMap: ContentSourceMap | undefined,\n  studioUrl: Exclude<StegaConfig['studioUrl'], undefined> | undefined,\n  basePath?: StudioPathLike,\n): EncodeDataAttributeFunction {\n  const parse = (path?: StudioPathLike) => {\n    if (!path) return []\n    return typeof path === 'string' ? studioPath.fromString(path) : path\n  }\n\n  const parsedBasePath = parse(basePath)\n\n  // This function should encode the given attribute based on the result, sourceMap, and studioUrl\n  return Object.assign(\n    (path: StudioPathLike) =>\n      encodeDataAttribute(result, sourceMap, studioUrl, [...parsedBasePath, ...parse(path)]),\n    // The scope method creates a scoped version of encodeDataAttribute\n    {\n      scope: (scope: StudioPathLike) =>\n        defineEncodeDataAttribute(result, sourceMap, studioUrl, [\n          ...parsedBasePath,\n          ...parse(scope),\n        ]),\n    },\n  )\n}\n"],"names":["encodeDataAttribute","result","sourceMap","studioUrl","studioPathLike","resultPath","studioPathToJsonPath","editInfo","resolveEditInfo","resultSourceMap","encodeSanityNodeData","baseUrl","workspace","tool","type","id","path","studioPath","toString","jsonPathToStudioPath","exports","defineEncodeDataAttribute","basePath","parse","fromString","parsedBasePath","Object","assign","scope"],"mappings":"+JAcO,MAAMA,EAAoD,CAC/DC,EACAC,EACAC,EACAC,KAEI,IAACF,IAAcC,EACjB,OAEF,MAAME,EAAaC,EAAAA,qBAAqBF,GAElCG,EAAWC,EAAAA,gBAAgB,CAC/BH,aACAI,gBAAiBP,EACjBC,cAEG,OAAAI,EAIEG,IAAqB,CAC1BC,QAASJ,EAASI,QAClBC,UAAWL,EAASK,UACpBC,KAAMN,EAASM,KACfC,KAAMP,EAASO,KACfC,GAAIR,EAASQ,GACbC,KAC2B,iBAAlBT,EAASS,KACZT,EAASS,KACTC,EAAAA,WAAWC,SAASC,EAAAA,qBAAqBZ,EAASS,cAbrD,CAcJ,EA0CHI,QAAAC,0BA1BO,SAASA,EACdpB,EACAC,EACAC,EACAmB,GAEA,MAAMC,EAASP,GACRA,EACkB,iBAATA,EAAoBC,EAAAA,WAAWO,WAAWR,GAAQA,EAD9C,GAIdS,EAAiBF,EAAMD,GAG7B,OAAOI,OAAOC,QACXX,GACChB,EAAoBC,EAAQC,EAAWC,EAAW,IAAIsB,KAAmBF,EAAMP,MAEjF,CACEY,MAAQA,GACNP,EAA0BpB,EAAQC,EAAWC,EAAW,IACnDsB,KACAF,EAAMK,MAInB,EAAAR,QAAApB,oBAAAA"}