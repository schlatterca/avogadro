{"version":3,"file":"enableLiveMode.cjs","sources":["../../../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/rng.js","../../../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/stringify.js","../../../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/native.js","../../../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/v4.js","../../../channels/src/constants.ts","../../../channels/src/helpers.ts","../../../channels/src/node.ts","../../src/live-mode/enableLiveMode.ts"],"sourcesContent":["// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","import type {ChannelMsgType} from './types'\n\nexport const RESPONSE_TIMEOUT = 1000\nexport const HEARTBEAT_INTERVAL = 1000\nexport const HANDSHAKE_INTERVAL = 500\n\nexport const INTERNAL_MSG_TYPES = [\n  'channel/disconnect',\n  'channel/response',\n  'channel/heartbeat',\n] satisfies ChannelMsgType[]\n\nexport const HANDSHAKE_MSG_TYPES = [\n  'handshake/syn',\n  'handshake/syn-ack',\n  'handshake/ack',\n] satisfies ChannelMsgType[]\n","import {HANDSHAKE_MSG_TYPES, INTERNAL_MSG_TYPES} from './constants'\nimport type {ChannelMsgType, HandshakeMsgType, InternalMsgType} from './types'\n\nexport const isInternalMessage = (\n  type: ChannelMsgType | InternalMsgType,\n): type is InternalMsgType => {\n  return INTERNAL_MSG_TYPES.some((t) => t === type)\n}\n\nexport const isHandshakeMessage = (\n  type: ChannelMsgType | InternalMsgType,\n): type is HandshakeMsgType => {\n  return HANDSHAKE_MSG_TYPES.some((t) => t === type)\n}\n\nexport const isLegacyHandshakeMessage = ({data = {}}: MessageEvent): boolean => {\n  return (\n    // Check data is a record type\n    typeof data === 'object' &&\n    data !== null &&\n    !Array.isArray(data) &&\n    // The \"domain\" key was introduced in commit 4854e7f\n    !('domain' in data) &&\n    // Check the rest of the object shape is present\n    ['id', 'type', 'from', 'to'].every((key) => key in data) &&\n    // Prior to 4854e7f only handshake events were emitted prior to an established connection\n    data.type.startsWith('handshake/')\n  )\n}\n","import {v4 as uuid} from 'uuid'\n\nimport {isHandshakeMessage, isInternalMessage, isLegacyHandshakeMessage} from './helpers'\nimport type {\n  ChannelMsg,\n  ChannelsEventSubscriber,\n  ChannelsNode,\n  ChannelsNodeChannel,\n  ChannelsNodeOptions,\n  ChannelsNodeStatusSubscriber,\n  ChannelStatus,\n  HandshakeMsgType,\n  InternalMsgType,\n  ProtocolMsg,\n  ToArgs,\n} from './types'\n\nexport function createChannelsNode<\n  ConnectionIds extends string,\n  Sends extends ChannelMsg,\n  Receives extends ChannelMsg,\n>(config: ChannelsNodeOptions<ConnectionIds>): ChannelsNode<Sends, Receives> {\n  const inFrame = window.self !== window.top || window.opener\n\n  const channel: ChannelsNodeChannel = {\n    buffer: [],\n    id: null,\n    origin: null,\n    source: null,\n    status: 'connecting',\n  }\n\n  function flush() {\n    const toFlush = [...channel.buffer]\n    channel.buffer.splice(0, channel.buffer.length)\n    toFlush.forEach(({type, data}) => {\n      send(type, data)\n    })\n  }\n\n  function send<T extends Sends['type']>(\n    type: T | InternalMsgType | HandshakeMsgType,\n    data?: Extract<Sends, {type: T}>['data'],\n  ) {\n    if (\n      !isHandshakeMessage(type) &&\n      !isInternalMessage(type) &&\n      (channel.status === 'connecting' || channel.status === 'reconnecting')\n    ) {\n      channel.buffer.push({type, data})\n      return\n    }\n\n    if (channel.id && channel.origin && channel.source) {\n      const msg: ProtocolMsg<Sends> = {\n        connectionId: channel.id,\n        data,\n        domain: 'sanity/channels',\n        from: config.id,\n        id: uuid(),\n        to: config.connectTo,\n        type,\n      }\n\n      try {\n        channel.source.postMessage(msg, {\n          targetOrigin: channel.origin,\n        })\n      } catch (e) {\n        throw new Error(`Failed to postMessage '${msg.id}' on '${config.id}'`)\n      }\n    }\n  }\n\n  function isValidMessageEvent(e: MessageEvent): e is MessageEvent<ProtocolMsg<Receives>> {\n    const {data} = e\n    return (\n      data.domain === 'sanity/channels' &&\n      data.to === config.id &&\n      data.from === config.connectTo &&\n      data.type !== 'channel/response'\n    )\n  }\n\n  function handleEvents(e: MessageEvent) {\n    if (isLegacyHandshakeMessage(e)) {\n      // eslint-disable-next-line no-console\n      console.error(\n        'Visual editing package mismatch detected! Please ensure you are using the latest version of Sanity Studio and any packages listed here:\\nhttps://github.com/sanity-io/visual-editing',\n      )\n      return\n    }\n\n    if (isValidMessageEvent(e)) {\n      const {data} = e\n      // Once we know the origin, after a valid handshake, we always verify it\n      if (channel.origin && e.origin !== channel.origin) {\n        return\n      }\n      // Always update the channel source reference, in case it changes\n      if (e.source && channel.source !== e.source) {\n        channel.source = e.source\n      }\n\n      if (isHandshakeMessage(data.type) && data.data) {\n        if (data.type === 'handshake/syn') {\n          channel.origin = e.origin\n          channel.id = data.data['id'] as string\n          setConnectionStatus('connecting')\n          send('handshake/syn-ack', {id: channel.id})\n          return\n        }\n        if (data.type === 'handshake/ack' && data.data['id'] === channel.id) {\n          setConnectionStatus('connected')\n          return\n        }\n      } else if (data.connectionId === channel.id && e.origin === channel.origin) {\n        if (data.type === 'channel/disconnect') {\n          setConnectionStatus('disconnected')\n          return\n        } else {\n          const args = [data.type, data.data] as ToArgs<Receives>\n          eventSubscribers.forEach((subscriber) => {\n            subscriber(...args)\n          })\n          send('channel/response', {responseTo: data.id})\n        }\n        return\n      }\n    }\n  }\n\n  const eventSubscribers = new Set<ChannelsEventSubscriber<Receives>>()\n\n  function subscribeToEvent(subscriber: ChannelsEventSubscriber<Receives>) {\n    eventSubscribers.add(subscriber)\n    return () => eventSubscribers.delete(subscriber)\n  }\n\n  function disconnect() {\n    if (['disconnected'].includes(channel.status)) return\n    // send('channel/disconnect', { id: channel.id })\n    setConnectionStatus('disconnected')\n  }\n\n  const statusSubscribers = new Set<ChannelsNodeStatusSubscriber>()\n\n  function subscribeToStatus(subscriber: ChannelsNodeStatusSubscriber) {\n    statusSubscribers.add(subscriber)\n    return () => statusSubscribers.delete(subscriber)\n  }\n\n  function setConnectionStatus(next: ChannelStatus) {\n    channel.status = next\n    statusSubscribers.forEach((subscriber) => {\n      subscriber(next)\n    })\n    if (next === 'connected') {\n      flush()\n    }\n  }\n\n  function destroy() {\n    disconnect()\n    eventSubscribers.clear()\n    statusSubscribers.clear()\n    window.removeEventListener('message', handleEvents, false)\n  }\n\n  function initialise() {\n    window.addEventListener('message', handleEvents, false)\n    setConnectionStatus('connecting')\n  }\n\n  initialise()\n\n  function sendPublic<T extends Sends['type']>(type: T, data?: Extract<Sends, {type: T}>['data']) {\n    send(type, data)\n  }\n\n  return {\n    destroy,\n    inFrame,\n    send: sendPublic,\n    subscribe: subscribeToEvent,\n    onStatusUpdate: subscribeToStatus,\n  }\n}\n","import {createChannelsNode} from '@repo/channels'\nimport type {\n  LoaderMsg,\n  LoaderPayloads,\n  VisualEditingConnectionIds,\n} from '@repo/visual-editing-helpers'\nimport {\n  type ClientPerspective,\n  type ContentSourceMap,\n  type ContentSourceMapDocuments,\n  type QueryParams,\n  SanityClient,\n} from '@sanity/client'\nimport {stegaEncodeSourceMap} from '@sanity/client/stega'\nimport {atom, type MapStore} from 'nanostores'\n\nimport type {EnableLiveModeOptions, QueryStoreState, SetFetcher} from '../types'\n\n/** @internal */\nexport interface LazyEnableLiveModeOptions extends EnableLiveModeOptions {\n  ssr: boolean\n  setFetcher: SetFetcher\n}\n\nconst LISTEN_HEARTBEAT_INTERVAL = 1000\n\nexport function enableLiveMode(options: LazyEnableLiveModeOptions): () => void {\n  const {client, setFetcher, onConnect, onDisconnect} = options\n  if (!client || !(client instanceof SanityClient)) {\n    throw new Error(\n      `Expected \\`client\\` to be an instance of SanityClient or SanityStegaClient: ${JSON.stringify(\n        client,\n      )}`,\n    )\n  }\n  const {projectId, dataset} = client.config()\n  const $perspective = atom<Exclude<ClientPerspective, 'raw'>>('previewDrafts')\n  const $connected = atom(false)\n\n  const cache = new Map<\n    string,\n    {\n      projectId: string\n      dataset: string\n      perspective: ClientPerspective\n      query: string\n      params: QueryParams\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      result: any\n      resultSourceMap?: ContentSourceMap | undefined\n    }\n  >()\n\n  const channel = createChannelsNode<VisualEditingConnectionIds, LoaderMsg, LoaderMsg>({\n    id: 'loaders',\n    connectTo: 'presentation',\n  })\n\n  channel.onStatusUpdate((status) => {\n    if (status === 'connected') {\n      $connected.set(true)\n    } else if (status === 'disconnected') {\n      $connected.set(false)\n    }\n  })\n\n  channel.subscribe((type, data) => {\n    if (type === 'loader/perspective' && data.projectId === projectId && data.dataset === dataset) {\n      if (data.perspective !== 'published' && data.perspective !== 'previewDrafts') {\n        throw new Error(`Unsupported perspective: ${JSON.stringify(data.perspective)}`)\n      }\n      $perspective.set(data.perspective)\n      updateLiveQueries()\n    } else if (\n      type === 'loader/query-change' &&\n      data.projectId === projectId &&\n      data.dataset === dataset\n    ) {\n      const {perspective, query, params} = data\n      if (\n        data.result !== undefined &&\n        data.resultSourceMap !== undefined &&\n        (client as SanityClient).config().stega.enabled\n      ) {\n        cache.set(JSON.stringify({perspective, query, params}), {\n          ...data,\n          result: stegaEncodeSourceMap(\n            data.result,\n            data.resultSourceMap,\n            (client as SanityClient).config().stega,\n          ),\n        })\n      } else {\n        cache.set(JSON.stringify({perspective, query, params}), data)\n      }\n\n      updateLiveQueries()\n    }\n  })\n\n  let unsetFetcher: (() => void) | undefined\n  const unlistenConnection = $connected.listen((connected) => {\n    if (connected) {\n      unsetFetcher = setFetcher({\n        hydrate: (query, params, initial) => {\n          const perspective = initial?.perspective || $perspective.get()\n          const key = JSON.stringify({\n            perspective,\n            query,\n            params,\n          })\n          const snapshot = cache.get(key)\n          if (snapshot?.result !== undefined && snapshot?.resultSourceMap !== undefined) {\n            return {\n              loading: false,\n              error: undefined,\n              data: snapshot.result,\n              sourceMap: snapshot.resultSourceMap,\n              perspective,\n            }\n          }\n\n          return {\n            loading:\n              ($connected.value === true && initial?.data === undefined) ||\n              initial?.sourceMap === undefined,\n            error: undefined,\n            data: initial?.data,\n            sourceMap: initial?.sourceMap,\n            perspective: initial?.perspective || 'published',\n          }\n        },\n        fetch: <QueryResponseResult, QueryResponseError>(\n          query: string,\n          params: QueryParams,\n          $fetch: MapStore<QueryStoreState<QueryResponseResult, QueryResponseError>>,\n          controller: AbortController,\n        ) => {\n          try {\n            const removeLiveQuery = addLiveQuery(query, params, $fetch)\n            controller.signal.addEventListener(\n              'abort',\n              () => {\n                removeLiveQuery()\n                updateLiveQueries()\n              },\n              {\n                once: true,\n              },\n            )\n            updateLiveQueries()\n            $fetch.setKey('error', undefined)\n            if (controller.signal.aborted) return\n          } catch (error: unknown) {\n            $fetch.setKey('error', error as QueryResponseError)\n            $fetch.setKey('loading', false)\n          }\n        },\n      })\n      onConnect?.()\n    } else {\n      unsetFetcher?.()\n      onDisconnect?.()\n    }\n  })\n\n  const liveQueries = new Set<{\n    query: string\n    params: QueryParams\n    $fetch: MapStore<QueryStoreState<any, any>>\n  }>()\n  const addLiveQuery = (\n    query: string,\n    params: QueryParams,\n    $fetch: MapStore<QueryStoreState<any, any>>,\n  ) => {\n    const liveQuery = {query, params, $fetch}\n    liveQueries.add(liveQuery)\n    emitQueryListen()\n    const interval = setInterval(() => emitQueryListen(true), LISTEN_HEARTBEAT_INTERVAL)\n    return () => {\n      clearInterval(interval)\n      liveQueries.delete(liveQuery)\n      emitQueryListen()\n    }\n  }\n  const emitQueryListen = (skipSetLoading?: boolean) => {\n    if (!channel) {\n      throw new Error('No channel')\n    }\n    const perspective = $perspective.get()\n    for (const {query, params, $fetch} of liveQueries) {\n      channel.send('loader/query-listen', {\n        projectId: projectId!,\n        dataset: dataset!,\n        perspective,\n        query,\n        params,\n        heartbeat: LISTEN_HEARTBEAT_INTERVAL,\n      } satisfies LoaderPayloads['query-listen'])\n      if (!skipSetLoading && $connected.value === true) {\n        $fetch.setKey('loading', true)\n      }\n      $fetch.setKey('perspective', perspective)\n    }\n  }\n  function updateLiveQueries() {\n    const perspective = $perspective.get()\n    const documentsOnPage: ContentSourceMapDocuments = []\n    // Loop over liveQueries and apply cache\n    for (const {query, params, $fetch} of liveQueries) {\n      const key = JSON.stringify({perspective, query, params})\n      const value = cache.get(key)\n      if (value) {\n        $fetch.set({\n          data: value.result,\n          error: undefined,\n          loading: false,\n          perspective,\n          sourceMap: value.resultSourceMap,\n        })\n        documentsOnPage.push(...(value.resultSourceMap?.documents ?? []))\n      }\n    }\n    channel?.send('loader/documents', {\n      projectId: projectId!,\n      dataset: dataset!,\n      perspective,\n      documents: documentsOnPage,\n    })\n  }\n\n  return () => {\n    unsetFetcher?.()\n    unlistenConnection()\n    channel.destroy()\n  }\n}\n"],"names":["client","require","stega","index","getRandomValues","rnds8","Uint8Array","rng","crypto","bind","Error","byteToHex","i","push","toString","slice","native","randomUUID","v4","options","buf","offset","rnds","random","arr","unsafeStringify","INTERNAL_MSG_TYPES","HANDSHAKE_MSG_TYPES","isInternalMessage","type","some","t","isHandshakeMessage","isLegacyHandshakeMessage","data","Array","isArray","every","key","startsWith","createChannelsNode","config","inFrame","window","self","top","opener","channel","buffer","id","origin","source","status","send","msg","connectionId","domain","from","uuid","to","connectTo","postMessage","targetOrigin","handleEvents","e","console","error","isValidMessageEvent","setConnectionStatus","args","eventSubscribers","forEach","subscriber","responseTo","Set","statusSubscribers","next","toFlush","splice","length","flush","addEventListener","destroy","includes","clear","removeEventListener","subscribe","add","delete","onStatusUpdate","exports","enableLiveMode","setFetcher","onConnect","onDisconnect","SanityClient","JSON","stringify","projectId","dataset","$perspective","atom","$connected","a","cache","Map","unsetFetcher","set","perspective","updateLiveQueries","query","params","result","resultSourceMap","enabled","stegaEncodeSourceMap","unlistenConnection","listen","connected","hydrate","initial","get","snapshot","loading","sourceMap","value","fetch","$fetch","controller","removeLiveQuery","addLiveQuery","signal","once","setKey","aborted","liveQueries","liveQuery","emitQueryListen","interval","setInterval","clearInterval","skipSetLoading","heartbeat","_a","_b","documentsOnPage","documents"],"mappings":"aAAA,IAAAA,EAAAC,QAAA,kBAAAC,EAAAD,QAAA,wBAAAE,EAAAF,QAAA,eAGA,IAAIG,EACJ,MAAMC,EAAQ,IAAIC,WAAW,IACd,SAASC,IAEtB,IAAKH,IAEHA,SAAyBI,OAAW,KAAeA,OAAOJ,iBAAmBI,OAAOJ,gBAAgBK,KAAKD,SAEpGJ,GACG,MAAA,IAAIM,MAAM,4GAIpB,OAAON,EAAgBC,EACzB,CCXA,MAAMM,EAAY,GAElB,IAAA,IAASC,EAAI,EAAGA,EAAI,MAAOA,EACfD,EAAAE,MAAMD,EAAI,KAAOE,SAAS,IAAIC,MAAM,ICRhD,IAAeC,EAAA,CACbC,kBAFwBT,OAAW,KAAeA,OAAOS,YAAcT,OAAOS,WAAWR,KAAKD,SCIhG,SAASU,EAAGC,EAASC,EAAKC,GACxB,GAAIL,EAAOC,aAAeG,IAAQD,EAChC,OAAOH,EAAOC,aAIhB,MAAMK,GADNH,EAAUA,GAAW,IACAI,SAAWJ,EAAQZ,KAAOA,KAE/C,OAAAe,EAAK,GAAe,GAAVA,EAAK,GAAY,GAC3BA,EAAK,GAAe,GAAVA,EAAK,GAAY,IFDtB,SAAyBE,EAAKH,EAAS,GAGrC,OAAAV,EAAUa,EAAIH,EAAS,IAAMV,EAAUa,EAAIH,EAAS,IAAMV,EAAUa,EAAIH,EAAS,IAAMV,EAAUa,EAAIH,EAAS,IAAM,IAAMV,EAAUa,EAAIH,EAAS,IAAMV,EAAUa,EAAIH,EAAS,IAAM,IAAMV,EAAUa,EAAIH,EAAS,IAAMV,EAAUa,EAAIH,EAAS,IAAM,IAAMV,EAAUa,EAAIH,EAAS,IAAMV,EAAUa,EAAIH,EAAS,IAAM,IAAMV,EAAUa,EAAIH,EAAS,KAAOV,EAAUa,EAAIH,EAAS,KAAOV,EAAUa,EAAIH,EAAS,KAAOV,EAAUa,EAAIH,EAAS,KAAOV,EAAUa,EAAIH,EAAS,KAAOV,EAAUa,EAAIH,EAAS,IAChf,CESSI,CAAgBH,EACzB,CCxBO,MAIMI,EAAqB,CAChC,qBACA,mBACA,qBAGWC,EAAsB,CACjC,gBACA,oBACA,iBCZWC,EACXC,GAEOH,EAAmBI,MAAMC,GAAMA,IAAMF,IAGjCG,EACXH,GAEOF,EAAoBG,MAAMC,GAAMA,IAAMF,IAGlCI,EAA2B,EAAEC,OAAO,MAG7B,iBAATA,GACE,OAATA,IACCC,MAAMC,QAAQF,MAEb,WAAYA,IAEd,CAAC,KAAM,OAAQ,OAAQ,MAAMG,OAAOC,GAAQA,KAAOJ,KAEnDA,EAAKL,KAAKU,WAAW,cCTlB,SAASC,EAIdC,GACA,MAAMC,EAAUC,OAAOC,OAASD,OAAOE,KAAOF,OAAOG,OAE/CC,EAA+B,CACnCC,OAAQ,GACRC,GAAI,KACJC,OAAQ,KACRC,OAAQ,KACRC,OAAQ,cAWD,SAAAC,EACPxB,EACAK,GAEA,GACGF,EAAmBH,IACnBD,EAAkBC,IACC,eAAnBkB,EAAQK,QAA8C,iBAAnBL,EAAQK,QAM9C,GAAIL,EAAQE,IAAMF,EAAQG,QAAUH,EAAQI,OAAQ,CAClD,MAAMG,EAA0B,CAC9BC,aAAcR,EAAQE,GACtBf,OACAsB,OAAQ,kBACRC,KAAMhB,EAAOQ,GACbA,GAAIS,IACJC,GAAIlB,EAAOmB,UACX/B,QAGE,IACMkB,EAAAI,OAAOU,YAAYP,EAAK,CAC9BQ,aAAcf,EAAQG,QACvB,CACS,MACJ,MAAA,IAAIxC,MAAM,0BAA0B4C,EAAIL,WAAWR,EAAOQ,MAClE,CACF,OAtBEF,EAAQC,OAAOnC,KAAK,CAACgB,OAAMK,QAuB/B,CAYA,SAAS6B,EAAaC,GAChB,GAAA/B,EAAyB+B,GAEnBC,QAAAC,MACN,6LAKA,GAnBN,SAA6BF,GACrB,MAAA9B,KAACA,GAAQ8B,EACf,MACkB,oBAAhB9B,EAAKsB,QACLtB,EAAKyB,KAAOlB,EAAOQ,IACnBf,EAAKuB,OAAShB,EAAOmB,WACP,qBAAd1B,EAAKL,IAET,CAWMsC,CAAoBH,GAAI,CACpB,MAAA9B,KAACA,GAAQ8B,EAEf,GAAIjB,EAAQG,QAAUc,EAAEd,SAAWH,EAAQG,OACzC,OAOF,GAJIc,EAAEb,QAAUJ,EAAQI,SAAWa,EAAEb,SACnCJ,EAAQI,OAASa,EAAEb,QAGjBnB,EAAmBE,EAAKL,OAASK,EAAKA,KAAM,CAC1C,GAAc,kBAAdA,EAAKL,KAKP,OAJAkB,EAAQG,OAASc,EAAEd,OACnBH,EAAQE,GAAKf,EAAKA,KAAKe,GACvBmB,EAAoB,mBACpBf,EAAK,oBAAqB,CAACJ,GAAIF,EAAQE,KAGzC,GAAkB,kBAAdf,EAAKL,MAA4BK,EAAKA,KAAKe,KAAUF,EAAQE,GAE/D,YADAmB,EAAoB,YAEtB,MAAA,GACSlC,EAAKqB,eAAiBR,EAAQE,IAAMe,EAAEd,SAAWH,EAAQG,OAAQ,CACtE,GAAc,uBAAdhB,EAAKL,KAEP,YADAuC,EAAoB,gBAEf,CACL,MAAMC,EAAO,CAACnC,EAAKL,KAAMK,EAAKA,MACboC,EAAAC,SAASC,IACxBA,KAAcH,EAAI,IAEpBhB,EAAK,mBAAoB,CAACoB,WAAYvC,EAAKe,IAC7C,CACA,MACF,CACF,CACF,CAEM,MAAAqB,MAAuBI,IAavB,MAAAC,MAAwBD,IAO9B,SAASN,EAAoBQ,GAC3B7B,EAAQK,OAASwB,EACjBD,EAAkBJ,SAASC,IACzBA,EAAWI,EAAI,IAEJ,cAATA,GA7HN,WACE,MAAMC,EAAU,IAAI9B,EAAQC,QAC5BD,EAAQC,OAAO8B,OAAO,EAAG/B,EAAQC,OAAO+B,QACxCF,EAAQN,SAAQ,EAAE1C,OAAMK,WACtBmB,EAAKxB,EAAMK,EAAI,GAEnB,CAwHI8C,EAEJ,CAoBO,OAVLrC,OAAOsC,iBAAiB,UAAWlB,GAAc,GACjDK,EAAoB,cASf,CACLc,QAnBF,WAtBM,CAAC,gBAAgBC,SAASpC,EAAQK,SAEtCgB,EAAoB,gBAsBpBE,EAAiBc,QACjBT,EAAkBS,QAClBzC,OAAO0C,oBAAoB,UAAWtB,GAAc,EACtD,EAeErB,UACAW,KAPO,SAAoCxB,EAASK,GACpDmB,EAAKxB,EAAMK,EACb,EAMEoD,UAlDF,SAA0Bd,GACxB,OAAAF,EAAiBiB,IAAIf,GACd,IAAMF,EAAiBkB,OAAOhB,EACvC,EAgDEiB,eAtCF,SAA2BjB,GACzB,OAAAG,EAAkBY,IAAIf,GACf,IAAMG,EAAkBa,OAAOhB,EACxC,EAqCF,CCkDAkB,QAAAC,eAnNO,SAAwBxE,GAC7B,MAAMnB,OAACA,EAAAA,WAAQ4F,EAAYC,UAAAA,EAAAC,aAAWA,GAAgB3E,EAClD,KAACnB,GAAYA,aAAkB+F,gBACjC,MAAM,IAAIrF,MACR,+EAA+EsF,KAAKC,UAClFjG,MAIA,MAAAkG,UAACA,UAAWC,GAAWnG,EAAOyC,SAC9B2D,EAAeC,EAAAA,EAAwC,iBACvDC,EAAaD,EAAAE,GAAK,GAElBC,EAAY,IAAAC,IAcZ1D,EAAUP,EAAqE,CACnFS,GAAI,UACJW,UAAW,iBA6CT,IAAA8C,EA1CI3D,EAAA0C,gBAAgBrC,IACP,cAAAA,EACbkD,EAAWK,KAAI,GACK,iBAAXvD,GACTkD,EAAWK,KAAI,EAAK,IAIxB5D,EAAQuC,WAAU,CAACzD,EAAMK,KACvB,GAAa,uBAATL,GAAiCK,EAAKgE,YAAcA,GAAahE,EAAKiE,UAAYA,EAAS,CAC7F,GAAyB,cAArBjE,EAAK0E,aAAoD,kBAArB1E,EAAK0E,YACrC,MAAA,IAAIlG,MAAM,4BAA4BsF,KAAKC,UAAU/D,EAAK0E,gBAElER,EAAaO,IAAIzE,EAAK0E,aACtBC,GAAkB,MAAA,GAET,wBAAThF,GACAK,EAAKgE,YAAcA,GACnBhE,EAAKiE,UAAYA,EACjB,CACA,MAAMS,YAACA,EAAAE,MAAaA,EAAOC,OAAAA,GAAU7E,OAEnB,IAAhBA,EAAK8E,aACoB,IAAzB9E,EAAK+E,iBACJjH,EAAwByC,SAASvC,MAAMgH,QAExCV,EAAMG,IAAIX,KAAKC,UAAU,CAACW,cAAaE,QAAOC,WAAU,IACnD7E,EACH8E,OAAQG,EAAAA,qBACNjF,EAAK8E,OACL9E,EAAK+E,gBACJjH,EAAwByC,SAASvC,SAItCsG,EAAMG,IAAIX,KAAKC,UAAU,CAACW,cAAaE,QAAOC,WAAU7E,GAG1D2E,GACF,KAIF,MAAMO,EAAqBd,EAAWe,QAAQC,IACxCA,GACFZ,EAAed,EAAW,CACxB2B,QAAS,CAACT,EAAOC,EAAQS,KACjB,MAAAZ,SAAcY,WAASZ,cAAeR,EAAaqB,MACnDnF,EAAM0D,KAAKC,UAAU,CACzBW,cACAE,QACAC,WAEIW,EAAWlB,EAAMiB,IAAInF,GACvB,YAAqB,KAAX,MAAVoF,OAAU,EAAAA,EAAAV,cAAsD,KAA9B,MAAAU,OAAA,EAAAA,EAAUT,iBACvC,CACLU,SAAS,EACTzD,WAAO,EACPhC,KAAMwF,EAASV,OACfY,UAAWF,EAAST,gBACpBL,eAIG,CACLe,SACwB,IAArBrB,EAAWuB,YAAoC,WAAlBL,WAAStF,YAChB,WAAvBsF,WAASI,WACX1D,WAAO,EACPhC,KAAe,MAATsF,OAAS,EAAAA,EAAAtF,KACf0F,UAAoB,MAATJ,OAAS,EAAAA,EAAAI,UACpBhB,mBAAaY,WAASZ,cAAe,YAAA,EAGzCkB,MAAO,CACLhB,EACAC,EACAgB,EACAC,KAEI,IACF,MAAMC,EAAkBC,EAAapB,EAAOC,EAAQgB,GAapD,GAZAC,EAAWG,OAAOlD,iBAChB,SACA,KACEgD,IACApB,MAEF,CACEuB,MAAM,IAGVvB,IACAkB,EAAOM,OAAO,aAAS,GACnBL,EAAWG,OAAOG,QAAS,aACxBpE,GACP6D,EAAOM,OAAO,QAASnE,GACvB6D,EAAOM,OAAO,WAAW,EAC3B,KAGJ,MAAAxC,GAAAA,MAGA,MADAa,GACAA,IAAA,MAAAZ,GAAAA,IAAA,IAIEyC,EAAkB,IAAA7D,IAKlBwD,EAAe,CACnBpB,EACAC,EACAgB,KAEA,MAAMS,EAAY,CAAC1B,QAAOC,SAAQgB,UACtBQ,EAAAhD,IAAIiD,GAChBC,IACA,MAAMC,EAAWC,aAAY,IAAMF,GAAgB,IA3JrB,KA4J9B,MAAO,KACLG,cAAcF,GACdH,EAAY/C,OAAOgD,GACnBC,IAAgB,EAGdA,EAAmBI,IACvB,IAAK9F,EACG,MAAA,IAAIrC,MAAM,cAEZ,MAAAkG,EAAcR,EAAaqB,MACjC,IAAA,MAAWX,MAACA,EAAAC,OAAOA,EAAQgB,OAAAA,KAAWQ,EACpCxF,EAAQM,KAAK,sBAAuB,CAClC6C,YACAC,UACAS,cACAE,QACAC,SACA+B,UA9K0B,OAgLvBD,IAAuC,IAArBvC,EAAWuB,OAChCE,EAAOM,OAAO,WAAW,GAE3BN,EAAOM,OAAO,cAAezB,EAAW,EAG5C,SAASC,IA9MX,IAAAkC,EAAAC,EA+MI,MAAMpC,EAAcR,EAAaqB,MAC3BwB,EAA6C,GAEnD,IAAA,MAAWnC,MAACA,EAAAC,OAAOA,EAAQgB,OAAAA,KAAWQ,EAAa,CACjD,MAAMjG,EAAM0D,KAAKC,UAAU,CAACW,cAAaE,QAAOC,WAC1Cc,EAAQrB,EAAMiB,IAAInF,GACpBuF,IACFE,EAAOpB,IAAI,CACTzE,KAAM2F,EAAMb,OACZ9C,WAAO,EACPyD,SAAS,EACTf,cACAgB,UAAWC,EAAMZ,kBAEnBgC,EAAgBpI,QAAS,OAAAmI,EAAA,OAAMD,EAAAlB,EAAAZ,sBAAiB,EAAA8B,EAAAG,WAAaF,EAAA,IAEjE,CACA,MAAAjG,GAAAA,EAASM,KAAK,mBAAoB,CAChC6C,YACAC,UACAS,cACAsC,UAAWD,GAEf,CAEA,MAAO,KAEL,MAAAvC,GAAAA,IAAAU,IACArE,EAAQmC,UAEZ","x_google_ignoreList":[0,1,2,3]}